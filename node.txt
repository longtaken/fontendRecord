第1章
node简介

1.1 node诞生历程
2009年5月，Ryan Dahl在github上发布最初的版本

1.4 node的特点
1.4.1 异步I/O
1.4.2 事件与回调函数

1.4.3 单线程
      单线程弱点：无法利用多核CPU、错误会引起整个应用退出，应用健壮性值得考验、大量计算占用CPU导致无法继续调用异步I/O
      
      node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。
      子进程的出现，意味着node可以从容应对单线程在健壮性和无法利用多核CPU方面的问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。
      通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的健壮性

1.4.4 跨平台


1.5 node的应用场景

1.5.1 I/O密集型
      I/O密集的优势主要在于node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少
      
1.5.2 是否不擅长CPU密集型业务
      CPU密集型应用给node带来挑战主要是：由于javascript单线程的原因，如果有长时间运行的计算（循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起。
      关于CPU密集型应用，node的异步I/O已经解决了在单线程上CPU与I/O之间阻塞无法重叠利用的问题，I/O阻塞造成的性能浪费远比CPU的影响小。
      长时间的运行计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景需要重新评估，这类计算比阻塞I/O还影响效率（纯计算场景），根本没有I/O。此类应用场景或许应当采用多线程的方式进行计算。
      node没有提供多线程用于计算支持，但有两个方式来充分利用CPU：
      1，node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++实现。
      2，如果单线程的node不能满足需求，那么通过子进程的方式，将一部分node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样能充分利用多CPU。
      
1.5.3 与遗留系统和平共处

1.5.4 分布式应用
      分布式应用意味着对可伸缩性的要求非常高。
      node高效利用并行I/O的过程，也是高效实用数据库的过程。对于node，这个行为只是一次普通的I/O。对于数据库而言，却是一次复杂的计算，所以也是进而充分压榨硬件资源的过程。
      
1.6 node的使用者 
1.7 参考资源



第2章
模块机制

2.1 commonjs规范
2.1.1 commonjs的出发点

2.1.2 commonjs的模块规范
      1，模块引用
         require()方法接受模块标识，以此引入一个模块的api到当前上下文中
      2，模块定义
         对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。
         模块中还存在一个module对象，它代表模块自身，而exports是module的属性。
         在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式
         //a.js  exports.add=fn; b.js  var a = require('a');a.add();
      3，模块标识
         模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有后缀.js
      commonjs构建的模块导出和引入机制使得用户不必考虑变量污染
2.2 node的模块实现
    node的实现并非完全按照规范，而是对模块规范进行取舍，同事增加少许自身需要的特性
    node引入模块步骤
        1，路径分析。2，文件定位。3，编译执行。
    node模块分为两类
        一类是node提供的核心模块。
           核心模块在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行两个步骤可以省略。并且在路径分析中优先判断，所以它加载速度是最快的
        一类是用户编写的文件模块。
           文件模块是在运行时动态加载，需要完成的路径分析、文件定位、编译执行过程，速度比核心模块慢。
           
2.2.1 优先从缓存加载
    node引入的模块会进行缓存，以减少二次引入时的开销。不同于浏览器缓存只文件，node缓存的是编译和执行之后的对象。
    不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查
    
2.2.2 路径分析和文件定位
    因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异
    1，模块标识符分析
      require方法接受一个标识符作为参数，在node实现中，正是基于这样一个标识符进行模块查找。模块标识符在node中主要分以下几类
      - 核心模块，如http，fs，path等
      - .或..开始的相对路径文件模块
      - 以/开始的绝对路径文件模块
      - 非路径形式的文件模块，如自定义的connect模块
      核心模块
      核心模块的优先级仅次于缓存加载，在node的源代码编译过程中已经编译为二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。
      以路径形式的文件模块
      以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析文件模块时，require方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的经过存放到缓存中，以使二次加载时更快。由于文件模块给node指明了确切的文件位置，所以在查找过程中可以节约大量时间，加载速度慢于核心模块。
      自定义模块
      自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。
      * 模块路径是node在定位文件模块的具体文件时定制的查找策略，具体表现为一个路径组成的数组。 
      模块路径的生成规则：当前文件目录下的node_modules目录。父目录下的node_modules目录。父目录的父目录下的node_modules目录。沿路径向上逐级递归，直到根目录下的node_modules目录。
      生成方式与js的原型链或者作用域的查找方式类似。加载过程中node会逐个尝试模块路径中的路径，直到找到目标文件为止。当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。
    2，文件定位
      从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率
      文件扩展名分析
        require在分析标识符的过程中，会出现标识符不包含文件扩展名的情况。commonjs模块规范也允许在标识符中不包含文件扩展名，这种情况下，node会按.js、.json、.node的次序补足扩展名，依次尝试。
        在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为node是单线程的，所以这里是一个会引起性能问题的地方。
        tips1：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。
        tips2：同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷
      目录分析
        在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时node会将目录当做一个包来处理
        在这个过程中，node对commonjs包规范进行了一定程度的支持。
        首先，node在当前目录下查找package.json（commonjs包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析步骤。
        如果main属性指定的文件名错误，或者没有package.json文件，node会将index当做默认文件名，然后依次查找index.js、index.json、index.node
        如果在目录分析过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没找到目标文件，则抛出查找失败的异常。
        
2.2.3 模块编译
    在node中，每个文件模块都是一个对象，它的定义如下：
    function Module(id, parent){
      this.id = id;
      this.exports = {};
      if (parent && parent.children) {
        parent.children.push(this);
      }
      this.filename = null;
      this.loaded = false;
      this.children = [];
    }
    编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也不同
        .js文件。通过fs模块同步读取文件后编译执行
        .node文件。这是用c/c++编写的扩展文件，通过dlopen()方法加载最后编译生产的文件
        .json文件。通过fs模块同步读取文件后，同JSON.parse()解析返回结果
        其余扩展名，都被当做.js文件载入
        每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能
        根据不同的文件扩展名，node会调用不同的读取方法
     
        
        
        
        
        
        
        
        
        
