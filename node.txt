第1章
node简介

1.1 node诞生历程
2009年5月，Ryan Dahl在github上发布最初的版本

1.4 node的特点
1.4.1 异步I/O
1.4.2 事件与回调函数

1.4.3 单线程
      单线程弱点：无法利用多核CPU、错误会引起整个应用退出，应用健壮性值得考验、大量计算占用CPU导致无法继续调用异步I/O
      
      node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。
      子进程的出现，意味着node可以从容应对单线程在健壮性和无法利用多核CPU方面的问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。
      通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的健壮性

1.4.4 跨平台


1.5 node的应用场景

1.5.1 I/O密集型
      I/O密集的优势主要在于node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少
      
1.5.2 是否不擅长CPU密集型业务
      CPU密集型应用给node带来挑战主要是：由于javascript单线程的原因，如果有长时间运行的计算（循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起。
      关于CPU密集型应用，node的异步I/O已经解决了在单线程上CPU与I/O之间阻塞无法重叠利用的问题，I/O阻塞造成的性能浪费远比CPU的影响小。
      长时间的运行计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景需要重新评估，这类计算比阻塞I/O还影响效率（纯计算场景），根本没有I/O。此类应用场景或许应当采用多线程的方式进行计算。
      node没有提供多线程用于计算支持，但有两个方式来充分利用CPU：
      1，node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++实现。
      2，如果单线程的node不能满足需求，那么通过子进程的方式，将一部分node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样能充分利用多CPU。
      
1.5.3 与遗留系统和平共处

1.5.4 分布式应用
      分布式应用意味着对可伸缩性的要求非常高。
      node高效利用并行I/O的过程，也是高效实用数据库的过程。对于node，这个行为只是一次普通的I/O。对于数据库而言，却是一次复杂的计算，所以也是进而充分压榨硬件资源的过程。
      
1.6 node的使用者 
1.7 参考资源



第2章
模块机制

2.1 commonjs规范
2.1.1 commonjs的出发点

2.1.2 commonjs的模块规范
      1，模块引用
         require()方法接受模块标识，以此引入一个模块的api到当前上下文中
      2，模块定义
         对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。
         模块中还存在一个module对象，它代表模块自身，而exports是module的属性。
         在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式
         //a.js  exports.add=fn; b.js  var a = require('a');a.add();
      3，模块标识
         模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有后缀.js
      commonjs构建的模块导出和引入机制使得用户不必考虑变量污染
2.2 node的模块实现
    node的实现并非完全按照规范，而是对模块规范进行取舍，同事增加少许自身需要的特性
    node引入模块步骤
        1，路径分析。2，文件定位。3，编译执行。
    node模块分为两类
        一类是node提供的核心模块。
           核心模块在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行两个步骤可以省略。并且在路径分析中优先判断，所以它加载速度是最快的
        一类是用户编写的文件模块。
           文件模块是在运行时动态加载，需要完成的路径分析、文件定位、编译执行过程，速度比核心模块慢。
           
2.2.1 优先从缓存加载
    node引入的模块会进行缓存，以减少二次引入时的开销。不同于浏览器缓存只文件，node缓存的是编译和执行之后的对象。
    不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查
    
2.2.2 路径分析和文件定位
    因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异
    1，模块标识符分析
      require方法接受一个标识符作为参数，在node实现中，正是基于这样一个标识符进行模块查找。模块标识符在node中主要分以下几类
      - 核心模块，如http，fs，path等
      - .或..开始的相对路径文件模块
      - 以/开始的绝对路径文件模块
      - 非路径形式的文件模块，如自定义的connect模块
      核心模块
      核心模块的优先级仅次于缓存加载，在node的源代码编译过程中已经编译为二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。
      以路径形式的文件模块
      以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析文件模块时，require方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的经过存放到缓存中，以使二次加载时更快。由于文件模块给node指明了确切的文件位置，所以在查找过程中可以节约大量时间，加载速度慢于核心模块。
      自定义模块
      自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。
      * 模块路径是node在定位文件模块的具体文件时定制的查找策略，具体表现为一个路径组成的数组。 
      模块路径的生成规则：当前文件目录下的node_modules目录。父目录下的node_modules目录。父目录的父目录下的node_modules目录。沿路径向上逐级递归，直到根目录下的node_modules目录。
      生成方式与js的原型链或者作用域的查找方式类似。加载过程中node会逐个尝试模块路径中的路径，直到找到目标文件为止。当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。
    2，文件定位
      从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率
      文件扩展名分析
        require在分析标识符的过程中，会出现标识符不包含文件扩展名的情况。commonjs模块规范也允许在标识符中不包含文件扩展名，这种情况下，node会按.js、.json、.node的次序补足扩展名，依次尝试。
        在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为node是单线程的，所以这里是一个会引起性能问题的地方。
        tips1：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。
        tips2：同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷
      目录分析
        在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时node会将目录当做一个包来处理
        在这个过程中，node对commonjs包规范进行了一定程度的支持。
        首先，node在当前目录下查找package.json（commonjs包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析步骤。
        如果main属性指定的文件名错误，或者没有package.json文件，node会将index当做默认文件名，然后依次查找index.js、index.json、index.node
        如果在目录分析过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没找到目标文件，则抛出查找失败的异常。
        
2.2.3 模块编译
    在node中，每个文件模块都是一个对象，它的定义如下：
    function Module(id, parent){
      this.id = id;
      this.exports = {};
      if (parent && parent.children) {
        parent.children.push(this);
      }
      this.filename = null;
      this.loaded = false;
      this.children = [];
    }
    编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也不同
        .js文件。通过fs模块同步读取文件后编译执行
        .node文件。这是用c/c++编写的扩展文件，通过dlopen()方法加载最后编译生产的文件
        .json文件。通过fs模块同步读取文件后，同JSON.parse()解析返回结果
        其余扩展名，都被当做.js文件载入
        每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能
        根据不同的文件扩展名，node会调用不同的读取方法，如.json文件的调用如下：
            Module._extension['.json'] = function(module, filename){
              var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
              try {
                module.exports = JSON.parse(stripBOM(content));
              } catch(e) {
                e.message = filename + ':' + e.message;
                throw e;
              }
            }
            Module._extension会被赋值给require()的extensions属性，所以可以console.log(require.extensions);//{ '.js': [Function], '.json': [Function], '.node': [Function] }

    确定文件扩展名后，node将调用具体的编译方式来将文件执行后返回给调用者
      1.javascript模块的编译
        在编译过程中，node对获取的JS文件内容进行了头尾包装。
        在头部添加了(function (exports, require, module, __filename, __dirname) {\n, \n});
        这样每个模块文件之间都进行了作用域隔离。包装后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的function对象。最后，将当前模块对象的exports属性、require方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function执行
        这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports属性被返回了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。
        这就是node对commonjs模块规范的实现。
        exports对象时通过形参的方式传入的，直接赋值形参会改变形参的引用，但不能改变作用域外的值（var a=10; !function(a){a=11;}(); a//10 ）
      2.c/c++模块的编译
        node调用process.dlopen()方法进行加载和执行。在node的架构下，dlopen()方法在windows和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。
        实际上，.node的模块文件并不需要编译，因为它是编写c/c++模块后编译生成的，所以只有加载和执行的过程。在执行过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。
        c/c++模块给node使用者带来的优势主要是执行效率方面的，劣势则是c/c++模块的编写门槛高
      3.JSON文件的编译
        .json文件的编译是3中方式中最简单的。node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse方法得到对象，然后将它赋值给模块对象的exports，以供外部调用
        JSON文件在用作项目的配置文件时比较有用。如果你定义了一个JSON文件作为配置，就不必调用fs模块去异步读取和解析，直接调用require引入即可。能享受模块缓存的便利，二次引入没有性能影响

2.3 核心模块
    node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块分为c/c++编写和js编写两部分，其中c/c++文件存放在node项目的src目录下，js放在lib目录下

2.3.1 js核心模块的编译过程
    1.转存为c/c++代码
      node采用v8附带的js2c.py工具，将所有内置的js代码（src/node.js和lib/*.js）转换成c++里的数组，生产node_natives.h头文件
      在这个过程，js代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动node进程时，js代码直接加载进内存中。在加载过程中，js核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一出一出查要快很多。
    2.编译js核心模块
      lib目录下的所有模块文件也没有定义require、module、exports这些变量。在引入js核心模块过程中，也经历了头尾包装的过程，然后才执行和导出exports对象。与文件模块有区别的地方在于：获取源代码的方式（核心模块是内存中加载的)以及缓存执行结果的位置。
      js核心模块的定义，源文件通过process.binding('natives')取出，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上：
      function NativeModule(id) {
        this.filename = id + '.js';
        this.id = id;
        this.exports = {};
        this.loaded = false;
      }
      NativeModule._source = process.binding('natives');
      NativeModule._cache = {};

2.3.2 c/c++核心模块的编译过程
    在核心模块中，有些模块全部由c/c++编写，有些模块则由c/c++完成核心部分，其他部分则由js实现包装或向外导出，以满足性能需求。c++为核心，JS实现封装的模式是node能够提高性能的常见方式。
    纯c/c++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。node的buffer、crypto、evals、fs、os等模块都是部分通过c/c++编写
    1.内建模块的组织形式
    struct node_module_struct {
      int version;
      void *dso_handle;
      const char * filename;
      void (*register_func) (v8::Handle<v8::Object> target);
      const char *modname;
    }      
    每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员：
    #define NODE_MODULE(modname, regfunc)
      extern "C" {
        NODE_MODULE_EXPORT node::node_module_struct modname ## _module =
        {
          NODE_STANDARD_MODULE_STUFF,
          regfunc,
          NODE_STRINGIFY(modname)
        };
      }
      node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有node_buffer,node_crypto,node_evals,node_fs,...
      node提供了get_builtin_module方法从node_module_list数组取出这些模块
      内建模块优势在于：本身由c/c++编写，性能优于脚本语言；在进行文件编译时，它们被编译进二进制文件。一旦node执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接可以执行
    2.内建模块的导出
      在node的所有模块类型中，存在（内建模块(c/c++)->核心模块(js)->文件模块）的依赖层级关系，文件模块可能会依赖核心模块，核心模块可能会依赖内建模块。
      通常，不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块
      node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块
      在加载内建模块时，先创建一个exports空对象，然后调用get_builtin_module方法取出内建模块对象，通过执行register_func填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出。

2.3.3 核心模块的引入流程
    os原生模块的引入流程
    NODE_MODULE(node_os, reg_func) -> get_builtin_module('node_os') -> process.binding('os') -> NativeModule.require('os') -> require('os')  

2.3.4 编写核心模块
    核心模块被编译进二进制文件需要遵循一定规则
    page26

2.4 c/c++扩展模块
    js的典型弱点是位运算，参照java的位运算实现，但是java位运算是int型数字的基础上进行，而js只有double型数据类型，再进行位运算过程中需要转成int型，所以js做位运算效率不高，需要编写c/c++扩展模块来提升性能

2.4.1 前提条件
    gyp项目生成工具
    v8引擎c++库
    libuv库
    node内部库

2.4.2 c/c++扩展模块的编写
    普通的扩展模块与内建模块的区别在于无须将源代码编译进node，而是通过dlopen方法动态加载。
    编写普通扩展模块时，无须将源代码编译进node命名空间，也不需要提供头文件

2.4.3 c/c++扩展模块的编译
    
2.4.4 c/c++扩展模块的加载

2.5 模块调用栈
    
2.6 包与NPM
    
2.6.1 包结构
    包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原目录。
    完全符合commonjs规范的包目录应该包含
    package.json：包描述文件
    bin：用于存放可执行二进制文件的目录
    lib：用于存放js代码的目录
    doc：用于存放文档的目录
    test：用于存放单元测试用例的代码

2.6.2 包描述文件与NPM
    name：包名，规范定义它需要由小写的字母和数字组成，可以包含.\_-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。不建议在包名中附带node或js重复标识它是js或node模块
    description：包简介
    version：版本号
    keywords： 关键词数组，npm中用来做分类搜索
    maintainers：包维护者列表，npm通过该属性进行权限认证
    contributors：贡献者列表
    bugs：一个可以反馈bug的网页地址或邮件地址
    licenses：当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用
    repositories：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码
    dependencies：使用当前包所需要依赖的包列表。npm会通过这个属性帮助自动加载依赖的包

    可选
    homepage：当前包的网站地址
    os：操作系统支持列表
    CPU：CPU架构的支持列表，arm mips ppc sparc x86 x86_64
    engine：支持的js引擎列表，ejs flusspferd gpsee jsc spidermonkey narwhal node v8
    builtin：标志当前包是否内建在底层系统的标准组件
    directories：包目录说明
    implements：实现规范的列表
    scripts：脚本说明对象

    在包规范的区别在于多了
    author：包作者
    bin：一些包做着希望包可以作为命令行工具使用。配置好bin字段后，通过npm i package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行直接执行。node-gyp就是这样安装。
    main：模块引入方法require在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果不存在这个字段，require会查找包目录下的index.js index.node index.json文件作为默认入口
    devDependencies：一些模块只在开发是需要的依赖

2.6.3 NPM常用功能
    commonjs包规范是理论，npm是一种实践。npm至于node，相当于gem之于ruby，pear之于php。
    1.查看帮助
      npm help <command>查看具体命令
      npm -v 版本
    2.安装依赖包
      npm install 安装好依赖包后，直接在代码调用require('xx')即可引入该包
      全局安装
        -g是将一个包安装为全局可用的执行命令。根据描述文件中bin字段配置，将实际脚本链接到与node可执行文件相同的路径下：'bin': {'express': './bin/express'}
        通过全局模式安装的所有模块包都被安装进了一个统一的目录下，通过path.resolve(process.execPath,'..','..','lib','node_modules')推算出来
        如果node可执行文件的位置是/user/local/bin/node，那么模块目录就是/usr/local/lib/node_module。通过软链接的方式将bin字段配置的可执行文件链接到node的可执行目录下
      本地安装
        本地安装只需为npm指明package.json文件所在的位置即可：它可以是一个包含package.json的存档文件，也可以是一个url地址，也可以是一个目录下package.json文件的目录位置
      从非官方源安装
        npm install underscore --registry=http://registry.url
        指定默认源
        npm config set registry http://registry.url
    3.npm钩子命令
      package.json中scripts字段让包安装或者卸载过程中提供钩子机制，'scripts': {'install':'install.js'}
    4.发布包
      编写模块
        保存xx.js
      初始化包描述文件
        npm init，创建package.json文件
      注册包仓库账号
        注册账号命令是npm adduser
      上传包
        npm publish <folder> 在package.json目录下执行npm publish . 开始上传包
      安装包
        npm i xx
      管理包权限
        npm owner ls eventproxy
        npm owner add eventproxy
        npm owner rm eventproxy
      分析包
        npm ls

2.6.4 局域npm
    搭建自己的npm仓库

2.6.5 npm潜在问题
    包质量良莠不齐

2.7 前后端共用模块
    
2.7.1 模块的侧重点
    
2.7.2 AMD规范
    AMD规范是commonjs模块规范的一个延伸,模块定义：
    define(id?, dependencies?, factory);
    AMD模块需要用define定义一个模块，而在node实现中是隐式包装的，它们的目的是作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或全局命名空间的方式。

2.7.3 CMD规范
    与AMD规范的区别在于定义模块和依赖引入的部分
    AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：
    define(['dep1', 'dep2'], function (dep1,dep2) { return function () {}; });
    
    CMD模块更接近于node对commonjs规范的定义：
    define(factory)

    在依赖部分，CMD支持动态引入：
    define(function(require, exports, module) {  });
    require、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require引入即可

2.7.4 兼容多种模块规范
    兼容node、AMD、CMD以及常见浏览器环境：
    (function (name, definition) {
      // 检测上下文环境是否为AMD或CMD
      var hasDefine = typeof define === 'function';

      // 检查上下文环境是否为node
      var hasExports = typof module !== 'undefined' && module.exprots;

      if (hasDefine) {
        // AMD/CMD环境
        define(definition);
      } else if (hasExports) {
        // 定义为普通node模块
        module.exports = definition();
      } else {
        // 将模块的执行结果挂在window变量中，在浏览器this指向window对象
        this[name] = deinition();
      }

    })('test', function () {
      var test = function () {};
      return test;
    });

2.8 总结
2.9 参考资源


第3章 异步I/O
    与node事件驱动、异步I/O设计理念比较相近的nginx采用C编写，性能优异。与node区别在于nginx具备面向客户端管理连接的强大能力，但它的背后依然受限于各种同步方式的编程语言。node既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。

3.1 为什么要异步I/O
    web应用已经不再是单台服务器就能胜任的时代，在跨网络的解构下，并发已经是现代变成中的标准配置了。

3.1.1 用户体验
    同步方式时间为M+N，异步方式时间为max(M+N)

3.1.2 资源分配
    计算机在发展过程中将组件进行了抽象，分为I/O设备和计算设备
    假设业务场景中有一组互不相关的任务需要完成，主流方法有两种：
      1.单线程串行依次执行
        串行执行的缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞
        在计算机资源中，通常I/O与CPU计算之间是可以并行进行的
        同步的编程模型导致的问题是，I/O的进行会让后续任务等待，造成资源不能被更好利用

      2.多线程并行完成
        如果创建多线程的开销小于并行执行，那么多线程的方式是首选的。
        多线程的代价在于创建线程和执行期线程上下文切换的开销较大。
        在复杂业务中，多线程编程经常面临锁、状态同步等问题。
        多线程在多核CPU上能够有效提升CPU的利用率
    
    node利用单线程，远离多线程死锁、状态同步问题，利用异步I/O，让单线程远离阻塞，更好利用cpu
    异步I/O可以算作ndoe特色，node是首个大规模将异步I/O应用在应用层上平台，力求在单线程上将资源分配得更高效
    为了弥补单线程无法利用多核CPU的缺点，node提供了类似前端中web workers的子进程，该子进程可以通过工作进程高效利用CPU和I/O
    异步I/O的提出是期望I/O的调用不再阻塞后续运算，将原有等待I/O完成的时间分配给其他需要的业务去执行

3.2 异步I/O实现现状

3.2.1 异步I/O与非阻塞I/O
    从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事
    操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果
    
    阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束
    以读取磁盘的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存之后，这个调用才结束

    阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O与阻塞I/O的差别为调用之后会立即返回
    非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务
    非阻塞I/O存在问题是由于完整的I/O没有完成，立即返回的并不是业务期望的数据，应用程序需要重复调用I/O操作来确认是否完成，这种重复调用判断操作是否完成的技术叫做轮询。
    非阻塞I/O需要轮询去确认是否完全完成数据获取，会让CPU处理状态判断，是对CPU资源的浪费。

    轮询技术
    read 重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。
    select 在read基础上改进。通过对文件描述符上的事件状态来进行判断。select轮询采用1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符
    poll 较select有所改进，采用链表的方式避免数组长度的限制，其次能避免不需要的检查。但当文件描述符较多的时候，性能还是低下
    epoll Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件将它唤醒。它是真实利用事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU
    kqueue 与epoll类似，仅在FreeBSD系统下存在
    轮询技术对于应用程序而言，仍只算一种同步，因为应用程序仍需要等待I/O完全返回。等待期间，CPU要么用于遍历文件描述符状态，要么用于休眠等待事件发生

3.2.2 理想的非阻塞异步I/O
    完美的异步I/O应该是应用程序发起的非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或回调数据传递给应用程序
    Linux存在这样的方式，原生提供一种异步I/O方式（AIO）就是通过信号或回调来传递数据。
    AIO仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存

3.2.3 现实的异步I/O
    通过让部分进程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就模拟实现了异步I/O    
    node是单线程，这里的单线程仅仅只是js执行在单线程中。在node中，内部完成I/O任务的另有线程池

3.3 node的异步I/O
    
3.3.1 事件循环
    node自身的执行模型--事件循环，正式它是的回调函数十分普遍
    在进程启动时，node便会创建一个类似于while(1)的循环，每执行一次循环体的过程称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下一个循环，如果不再有事件处理，就退出进程

3.3.2 观察者
    每个事件循环中有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。
    浏览器采用了类似机制。事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类
    事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理

3.3.3 请求对象
    windows下异步I/O（利用IOCP实现）
    对于一般的（非异步）回调函数，函数由我们自行调用
    对于node中异步I/O调用而言，回调函数不由开发者调用。
    从js发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，叫做请求对象
    fs.open = function(path, flags, mode, callback) {
      binding.open(pathModule._makeLong(path), stringToFlags(flags), mode, callback);
    };
    fs.open的作用是根据指定路径和参数去打开一个文件，从而得到一个文件描述符，这是后续所有I/O操作的初始操作。
    从JS调用node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用，这是node里经典的调用方式。

    请求对象时异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理

3.3.4 执行回调
    组装好请求对象、送入I/O线程池等待执行，实际上完成了异步I/O的第一部分，回调通知是第二部分。

    事件循环、观察者、请求对象、I/O线程池这四者共同构成了node异步I/O模型的基本要素

3.3.5 小结
    js是单线程，node自身是多线程的，只是I/O线程使用的CPU较少。
    除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O）则是可以并行起来的

3.4 非I/O的异步API
    node中存在一些与I/O无关的异步API：setTimeout、setInterval、setImmediate、process.nextTick

3.4.1 定时器
    setTimeout、setInterval与浏览器API一致，实现原理与异步I/O类似，只是不需要I/O线程池的参与。
    调用setTimeout、setInterval创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个时间，它的回调函数将立即执行。
    定时器的问题在于，它并非精确的。尽管事件循环十分快，但如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。

3.4.2 process.nextTick
    由于事件循环自身的特点，定时器的精确度不够。采用定时器需要动用红黑树，创建定时器对象和迭代等操作，而setTimeout(fn, 0)的方式较为浪费性能。process.nextTick方法的操作相对较为轻量
    process.nextTick = function(callback) {
      if (process._exiting) return;
      if (tickDepth >= process.maxTickDepth) maxTickWarn();

      var tock = { callback: callback };
      if (process.domain) tock.domain = process.domain;
      nextTickQueue.push(tock);
      if (nextTickQueue.length) process._needTickCallback();
    };
    每次调用process.nextTick方法，只会讲回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n)),nextTick的时间复杂度为O(1)。相比之下，process.nextTick更高效

3.4.3 setImmediate
    setImmediate方法与process.nextTick方法十分类似，都是将回调函数延迟执行。
    process.nextTick(function () {
      console.log('1');
    });
    setImmediate(function () {
      console.log('2');
    });
    console.log('0');
    //0 -> 1 -> 2
    process.nextTick中的回调函数执行优先级高于setImmediate
    原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick属于idle观察者，setImmediate属于check观察者。在每一个轮循环中，idle观察者先于I/O观察者，I/O观察者先于check观察者
    在具体实现上，process.nextTick的回调函数保存在一个数组中，setImmediate的结果保存在链表中。
    在行为上，process.nextTick在每轮循环中会将数组中的回调函数全部执行完，而setImmediate在每轮循环中执行链表的一个回调函数。

3.5 事件驱动与高性能服务器
    事件驱动的实质，通过主循环加事件触发的方式运行程序
    异步I/O不仅仅应用在文件操作中。对于网络套接字的处理，node也应用到了异步I/O，网络套接字上侦听到的请求都会形成事件交给I/O观察者。事件循环会不停地处理这些网络I/O事件。如果JS有传入回调函数，这些事件将会最终传递到业务逻辑层进行处理。利用node构建web服务器，正式在这样一个基础上实现的。
    
    服务器模型：
    同步式： 对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态
    每进程/每请求： 为每个请求启动一个进程，这样可以处理多个请求，但它不具备扩展性，因为系统资源固定
    每线程/每请求： 为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。每线程/每进程的扩展性比每进程/每请求的方式要好，但对于大型站点而言依然不够

    每线程/每请求的方式被Apache采用。
    node通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能从容处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是node高性能的一个原因

    nginx摒弃多线程的方式，采用和node相同的事件驱动。nginx大有取代Apache之势
    node具有与nginx相同的特性，不同之处在于nginx采用纯C编写，性能较高，但是它仅适合于做web服务器，用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺。
    node则是一套高性能的平台，可以利用它构建与nginx相同的功能，也可以处理各种具体业务，而且与背后的网络保持异步畅通。

3.6 总结
    事件循环是异步实现的核心，它与浏览器中的执行模型基本保持一致。

3.7 参考资源


第4章 异步编程



     
        
        
        
        
        
        
        
        
        
