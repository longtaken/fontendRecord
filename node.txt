第1章
node简介

1.1 node诞生历程
2009年5月，Ryan Dahl在github上发布最初的版本

1.4 node的特点
1.4.1 异步I/O
1.4.2 事件与回调函数
1.4.3 单线程
      单线程弱点：无法利用多核CPU、错误会引起整个应用退出，应用健壮性值得考验、大量计算占用CPU导致无法继续调用异步I/O
      
      node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。
      子进程的出现，意味着node可以从容应对单线程在健壮性和无法利用多核CPU方面的问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。
      通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的健壮性

1.4.4 跨平台


1.5 node的应用场景
1.5.1 I/O密集型
      I/O密集的优势主要在于node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少
1.5.2 是否不擅长CPU密集型业务
      CPU密集型应用给node带来挑战主要是：由于javascript单线程的原因，如果有长时间运行的计算（循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起。
      关于CPU密集型应用，node的异步I/O已经解决了在单线程上CPU与I/O之间阻塞无法重叠利用的问题，I/O阻塞造成的性能浪费远比CPU的影响小。
      长时间的运行计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景需要重新评估，这类计算比阻塞I/O还影响效率（纯计算场景），根本没有I/O。此类应用场景或许应当采用多线程的方式进行计算。
      node没有提供多线程用于计算支持，但有两个方式来充分利用CPU：
      1，node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++实现。
      2，如果单线程的node不能满足需求，那么通过子进程的方式，将一部分node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样能充分利用多CPU。
1.5.3 与遗留系统和平共处
1.5.4 分布式应用
      分布式应用意味着对可伸缩性的要求非常高。
      node高效利用并行I/O的过程，也是高效实用数据库的过程。对于node，这个行为只是一次普通的I/O。对于数据库而言，却是一次复杂的计算，所以也是进而充分压榨硬件资源的过程。
1.6 node的使用者 
1.7 参考资源



第2章
模块机制

2.1 commonjs规范
2.1.1 commonjs的出发点
2.1.2 commonjs的模块规范
      1，模块引用
         require()方法接受模块标识，以此引入一个模块的api到当前上下文中
      2，模块定义
         对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。
         模块中还存在一个module对象，它代表模块自身，而exports是module的属性。
         在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式
         //a.js  exports.add=fn; b.js  var a = require('a');a.add();
      3，模块标识
         模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有后缀.js
      commonjs构建的模块导出和引入机制使得用户不必考虑变量污染
2.2 node的模块实现
    node的实现并非完全按照规范，而是对模块规范进行取舍，同事增加少许自身需要的特性
    node引入模块步骤
        1，路径分析。2，文件定位。3，编译执行。
    node模块分为两类
        一类是node提供的核心模块。
           核心模块在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行两个步骤可以省略。并且在路径分析中优先判断，所以它加载速度是最快的
        一类是用户编写的文件模块。
           文件模块是在运行时动态加载，需要完成的路径分析、文件定位、编译执行过程，速度比核心模块慢。
2.2.1 优先从缓存加载
    node引入的模块会进行缓存，以减少二次引入时的开销。不同于浏览器缓存只文件，node缓存的是编译和执行之后的对象。
    不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查
2.2.2 路径分析和文件定位
