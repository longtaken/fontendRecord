第1章
node简介

1.1 node诞生历程
2009年5月，Ryan Dahl在github上发布最初的版本

1.4 node的特点
1.4.1 异步I/O
1.4.2 事件与回调函数

1.4.3 单线程
      单线程弱点：无法利用多核CPU、错误会引起整个应用退出，应用健壮性值得考验、大量计算占用CPU导致无法继续调用异步I/O
      
      node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。
      子进程的出现，意味着node可以从容应对单线程在健壮性和无法利用多核CPU方面的问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。
      通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的健壮性

1.4.4 跨平台


1.5 node的应用场景

1.5.1 I/O密集型
      I/O密集的优势主要在于node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少
      
1.5.2 是否不擅长CPU密集型业务
      CPU密集型应用给node带来挑战主要是：由于javascript单线程的原因，如果有长时间运行的计算（循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起。
      关于CPU密集型应用，node的异步I/O已经解决了在单线程上CPU与I/O之间阻塞无法重叠利用的问题，I/O阻塞造成的性能浪费远比CPU的影响小。
      长时间的运行计算，如果它的耗时超过普通阻塞I/O的耗时，那么应用场景需要重新评估，这类计算比阻塞I/O还影响效率（纯计算场景），根本没有I/O。此类应用场景或许应当采用多线程的方式进行计算。
      node没有提供多线程用于计算支持，但有两个方式来充分利用CPU：
      1，node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++实现。
      2，如果单线程的node不能满足需求，那么通过子进程的方式，将一部分node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样能充分利用多CPU。
      
1.5.3 与遗留系统和平共处

1.5.4 分布式应用
      分布式应用意味着对可伸缩性的要求非常高。
      node高效利用并行I/O的过程，也是高效实用数据库的过程。对于node，这个行为只是一次普通的I/O。对于数据库而言，却是一次复杂的计算，所以也是进而充分压榨硬件资源的过程。
      
1.6 node的使用者 
1.7 参考资源



第2章
模块机制

2.1 commonjs规范
2.1.1 commonjs的出发点

2.1.2 commonjs的模块规范
      1，模块引用
         require()方法接受模块标识，以此引入一个模块的api到当前上下文中
      2，模块定义
         对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。
         模块中还存在一个module对象，它代表模块自身，而exports是module的属性。
         在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式
         //a.js  exports.add=fn; b.js  var a = require('a');a.add();
      3，模块标识
         模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有后缀.js
      commonjs构建的模块导出和引入机制使得用户不必考虑变量污染
2.2 node的模块实现
    node的实现并非完全按照规范，而是对模块规范进行取舍，同事增加少许自身需要的特性
    node引入模块步骤
        1，路径分析。2，文件定位。3，编译执行。
    node模块分为两类
        一类是node提供的核心模块。
           核心模块在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行两个步骤可以省略。并且在路径分析中优先判断，所以它加载速度是最快的
        一类是用户编写的文件模块。
           文件模块是在运行时动态加载，需要完成的路径分析、文件定位、编译执行过程，速度比核心模块慢。
           
2.2.1 优先从缓存加载
    node引入的模块会进行缓存，以减少二次引入时的开销。不同于浏览器缓存只文件，node缓存的是编译和执行之后的对象。
    不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查
    
2.2.2 路径分析和文件定位
    因为标识符有几种形式，对于不同的标识符，模块的查找和定位有不同程度上的差异
    1，模块标识符分析
      require方法接受一个标识符作为参数，在node实现中，正是基于这样一个标识符进行模块查找。模块标识符在node中主要分以下几类
      - 核心模块，如http，fs，path等
      - .或..开始的相对路径文件模块
      - 以/开始的绝对路径文件模块
      - 非路径形式的文件模块，如自定义的connect模块
      核心模块
      核心模块的优先级仅次于缓存加载，在node的源代码编译过程中已经编译为二进制代码，其加载过程最快。如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。
      以路径形式的文件模块
      以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析文件模块时，require方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的经过存放到缓存中，以使二次加载时更快。由于文件模块给node指明了确切的文件位置，所以在查找过程中可以节约大量时间，加载速度慢于核心模块。
      自定义模块
      自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。
      * 模块路径是node在定位文件模块的具体文件时定制的查找策略，具体表现为一个路径组成的数组。 
      模块路径的生成规则：当前文件目录下的node_modules目录。父目录下的node_modules目录。父目录的父目录下的node_modules目录。沿路径向上逐级递归，直到根目录下的node_modules目录。
      生成方式与js的原型链或者作用域的查找方式类似。加载过程中node会逐个尝试模块路径中的路径，直到找到目标文件为止。当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。
    2，文件定位
      从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率
      文件扩展名分析
        require在分析标识符的过程中，会出现标识符不包含文件扩展名的情况。commonjs模块规范也允许在标识符中不包含文件扩展名，这种情况下，node会按.js、.json、.node的次序补足扩展名，依次尝试。
        在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为node是单线程的，所以这里是一个会引起性能问题的地方。
        tips1：如果是.node和.json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。
        tips2：同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷
      目录分析
        在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时node会将目录当做一个包来处理
        在这个过程中，node对commonjs包规范进行了一定程度的支持。
        首先，node在当前目录下查找package.json（commonjs包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析步骤。
        如果main属性指定的文件名错误，或者没有package.json文件，node会将index当做默认文件名，然后依次查找index.js、index.json、index.node
        如果在目录分析过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没找到目标文件，则抛出查找失败的异常。
        
2.2.3 模块编译
    在node中，每个文件模块都是一个对象，它的定义如下：
    function Module(id, parent){
      this.id = id;
      this.exports = {};
      if (parent && parent.children) {
        parent.children.push(this);
      }
      this.filename = null;
      this.loaded = false;
      this.children = [];
    }
    编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也不同
        .js文件。通过fs模块同步读取文件后编译执行
        .node文件。这是用c/c++编写的扩展文件，通过dlopen()方法加载最后编译生产的文件
        .json文件。通过fs模块同步读取文件后，同JSON.parse()解析返回结果
        其余扩展名，都被当做.js文件载入
        每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能
        根据不同的文件扩展名，node会调用不同的读取方法，如.json文件的调用如下：
            Module._extension['.json'] = function(module, filename){
              var content = NativeModule.require('fs').readFileSync(filename, 'utf8');
              try {
                module.exports = JSON.parse(stripBOM(content));
              } catch(e) {
                e.message = filename + ':' + e.message;
                throw e;
              }
            }
            Module._extension会被赋值给require()的extensions属性，所以可以console.log(require.extensions);//{ '.js': [Function], '.json': [Function], '.node': [Function] }

    确定文件扩展名后，node将调用具体的编译方式来将文件执行后返回给调用者
      1.javascript模块的编译
        在编译过程中，node对获取的JS文件内容进行了头尾包装。
        在头部添加了(function (exports, require, module, __filename, __dirname) {\n, \n});
        这样每个模块文件之间都进行了作用域隔离。包装后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的function对象。最后，将当前模块对象的exports属性、require方法、module（模块对象自身），以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function执行
        这就是这些变量并没有定义在每个模块文件中却存在的原因。在执行之后，模块的exports属性被返回了调用方。exports属性上的任何方法和属性都可以被外部调用到，但是模块中的其余变量或属性则不可直接被调用。
        这就是node对commonjs模块规范的实现。
        exports对象时通过形参的方式传入的，直接赋值形参会改变形参的引用，但不能改变作用域外的值（var a=10; !function(a){a=11;}(); a//10 ）
      2.c/c++模块的编译
        node调用process.dlopen()方法进行加载和执行。在node的架构下，dlopen()方法在windows和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。
        实际上，.node的模块文件并不需要编译，因为它是编写c/c++模块后编译生成的，所以只有加载和执行的过程。在执行过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。
        c/c++模块给node使用者带来的优势主要是执行效率方面的，劣势则是c/c++模块的编写门槛高
      3.JSON文件的编译
        .json文件的编译是3中方式中最简单的。node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse方法得到对象，然后将它赋值给模块对象的exports，以供外部调用
        JSON文件在用作项目的配置文件时比较有用。如果你定义了一个JSON文件作为配置，就不必调用fs模块去异步读取和解析，直接调用require引入即可。能享受模块缓存的便利，二次引入没有性能影响

2.3 核心模块
    node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块分为c/c++编写和js编写两部分，其中c/c++文件存放在node项目的src目录下，js放在lib目录下

2.3.1 js核心模块的编译过程
    1.转存为c/c++代码
      node采用v8附带的js2c.py工具，将所有内置的js代码（src/node.js和lib/*.js）转换成c++里的数组，生产node_natives.h头文件
      在这个过程，js代码以字符串的形式存储在node命名空间中，是不可直接执行的。在启动node进程时，js代码直接加载进内存中。在加载过程中，js核心模块经历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一出一出查要快很多。
    2.编译js核心模块
      lib目录下的所有模块文件也没有定义require、module、exports这些变量。在引入js核心模块过程中，也经历了头尾包装的过程，然后才执行和导出exports对象。与文件模块有区别的地方在于：获取源代码的方式（核心模块是内存中加载的)以及缓存执行结果的位置。
      js核心模块的定义，源文件通过process.binding('natives')取出，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上：
      function NativeModule(id) {
        this.filename = id + '.js';
        this.id = id;
        this.exports = {};
        this.loaded = false;
      }
      NativeModule._source = process.binding('natives');
      NativeModule._cache = {};

2.3.2 c/c++核心模块的编译过程
    在核心模块中，有些模块全部由c/c++编写，有些模块则由c/c++完成核心部分，其他部分则由js实现包装或向外导出，以满足性能需求。c++为核心，JS实现封装的模式是node能够提高性能的常见方式。
    纯c/c++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。node的buffer、crypto、evals、fs、os等模块都是部分通过c/c++编写
    1.内建模块的组织形式
    struct node_module_struct {
      int version;
      void *dso_handle;
      const char * filename;
      void (*register_func) (v8::Handle<v8::Object> target);
      const char *modname;
    }      
    每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员：
    #define NODE_MODULE(modname, regfunc)
      extern "C" {
        NODE_MODULE_EXPORT node::node_module_struct modname ## _module =
        {
          NODE_STANDARD_MODULE_STUFF,
          regfunc,
          NODE_STRINGIFY(modname)
        };
      }
      node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有node_buffer,node_crypto,node_evals,node_fs,...
      node提供了get_builtin_module方法从node_module_list数组取出这些模块
      内建模块优势在于：本身由c/c++编写，性能优于脚本语言；在进行文件编译时，它们被编译进二进制文件。一旦node执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接可以执行
    2.内建模块的导出
      在node的所有模块类型中，存在（内建模块(c/c++)->核心模块(js)->文件模块）的依赖层级关系，文件模块可能会依赖核心模块，核心模块可能会依赖内建模块。
      通常，不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块
      node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块
      在加载内建模块时，先创建一个exports空对象，然后调用get_builtin_module方法取出内建模块对象，通过执行register_func填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出。

2.3.3 核心模块的引入流程
    os原生模块的引入流程
    NODE_MODULE(node_os, reg_func) -> get_builtin_module('node_os') -> process.binding('os') -> NativeModule.require('os') -> require('os')  

2.3.4 编写核心模块
    核心模块被编译进二进制文件需要遵循一定规则
    page26

2.4 c/c++扩展模块
    js的典型弱点是位运算，参照java的位运算实现，但是java位运算是int型数字的基础上进行，而js只有double型数据类型，再进行位运算过程中需要转成int型，所以js做位运算效率不高，需要编写c/c++扩展模块来提升性能

2.4.1 前提条件
    gyp项目生成工具
    v8引擎c++库
    libuv库
    node内部库

2.4.2 c/c++扩展模块的编写
    普通的扩展模块与内建模块的区别在于无须将源代码编译进node，而是通过dlopen方法动态加载。
    编写普通扩展模块时，无须将源代码编译进node命名空间，也不需要提供头文件

2.4.3 c/c++扩展模块的编译
    
2.4.4 c/c++扩展模块的加载

2.5 模块调用栈
    
2.6 包与NPM
    
2.6.1 包结构
    包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原目录。
    完全符合commonjs规范的包目录应该包含
    package.json：包描述文件
    bin：用于存放可执行二进制文件的目录
    lib：用于存放js代码的目录
    doc：用于存放文档的目录
    test：用于存放单元测试用例的代码

2.6.2 包描述文件与NPM
    name：包名，规范定义它需要由小写的字母和数字组成，可以包含.\_-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。不建议在包名中附带node或js重复标识它是js或node模块
    description：包简介
    version：版本号
    keywords： 关键词数组，npm中用来做分类搜索
    maintainers：包维护者列表，npm通过该属性进行权限认证
    contributors：贡献者列表
    bugs：一个可以反馈bug的网页地址或邮件地址
    licenses：当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用
    repositories：托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码
    dependencies：使用当前包所需要依赖的包列表。npm会通过这个属性帮助自动加载依赖的包

    可选
    homepage：当前包的网站地址
    os：操作系统支持列表
    CPU：CPU架构的支持列表，arm mips ppc sparc x86 x86_64
    engine：支持的js引擎列表，ejs flusspferd gpsee jsc spidermonkey narwhal node v8
    builtin：标志当前包是否内建在底层系统的标准组件
    directories：包目录说明
    implements：实现规范的列表
    scripts：脚本说明对象

    在包规范的区别在于多了
    author：包作者
    bin：一些包做着希望包可以作为命令行工具使用。配置好bin字段后，通过npm i package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行直接执行。node-gyp就是这样安装。
    main：模块引入方法require在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口，如果不存在这个字段，require会查找包目录下的index.js index.node index.json文件作为默认入口
    devDependencies：一些模块只在开发是需要的依赖

2.6.3 NPM常用功能
    commonjs包规范是理论，npm是一种实践。npm至于node，相当于gem之于ruby，pear之于php。
    1.查看帮助
      npm help <command>查看具体命令
      npm -v 版本
    2.安装依赖包
      npm install 安装好依赖包后，直接在代码调用require('xx')即可引入该包
      全局安装
        -g是将一个包安装为全局可用的执行命令。根据描述文件中bin字段配置，将实际脚本链接到与node可执行文件相同的路径下：'bin': {'express': './bin/express'}
        通过全局模式安装的所有模块包都被安装进了一个统一的目录下，通过path.resolve(process.execPath,'..','..','lib','node_modules')推算出来
        如果node可执行文件的位置是/user/local/bin/node，那么模块目录就是/usr/local/lib/node_module。通过软链接的方式将bin字段配置的可执行文件链接到node的可执行目录下
      本地安装
        本地安装只需为npm指明package.json文件所在的位置即可：它可以是一个包含package.json的存档文件，也可以是一个url地址，也可以是一个目录下package.json文件的目录位置
      从非官方源安装
        npm install underscore --registry=http://registry.url
        指定默认源
        npm config set registry http://registry.url
    3.npm钩子命令
      package.json中scripts字段让包安装或者卸载过程中提供钩子机制，'scripts': {'install':'install.js'}
    4.发布包
      编写模块
        保存xx.js
      初始化包描述文件
        npm init，创建package.json文件
      注册包仓库账号
        注册账号命令是npm adduser
      上传包
        npm publish <folder> 在package.json目录下执行npm publish . 开始上传包
      安装包
        npm i xx
      管理包权限
        npm owner ls eventproxy
        npm owner add eventproxy
        npm owner rm eventproxy
      分析包
        npm ls

2.6.4 局域npm
    搭建自己的npm仓库

2.6.5 npm潜在问题
    包质量良莠不齐

2.7 前后端共用模块
    
2.7.1 模块的侧重点
    
2.7.2 AMD规范
    AMD规范是commonjs模块规范的一个延伸

     
        
        
        
        
        
        
        
        
        
