第一章
简介

babel安装
	npm i --global babel-cli
	npm i --save babel-preset-es2015
配置.babelrc
	{"presets":['es2015']}

babel自带一个babel-node命令，提供支持es6的REPL环境，支持nodejs的REPL环境的所有功能，可以直接运行ES6代码。
babel-node 回车后直接编写
babel-node es6.js 直接运行es6脚本
babel es6.js 	  将es6转为es5

-o参数（或--out-file）可以将转换后的代码从标准输出重定向至文件
babel es6.js -o es5.js	babel es6.js --out-file es5.js

-d参数用于转换整个目录
babel -d build-dir source-dir

-s参数生产source map
babel -d build-dir source-dir -s


nodejs环境
npm i -S babel-core babel-preset-2015
创建.babelrc {"presets":["es2015"]}
最后在脚本调用babel-core的transform方法

var es5Code='let x=n=>n+1';
var es6Code=require('babel-core').transform(es5Code,{presets:['es2015']}).code;
transform第一个参数是字符串，表示需要转换的ES5代码，第二个参数是转换的配置对象。

babel加载为require命令的一个钩子：
require("babel-core/register")
后面所有通过require加载的后缀名为.es6、.es、.jsx、.js的脚本都会通过babel转码再加载。

babel默认不会转换Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对

象上的方法（如Object.assign）。如需使用就安装
npm i babel-polyfill -S，然后require('babel-polyfill');






第二章
let const命令

let
let在代码块内有效
不存在变量提升（为声明之前使用typeof也会报错）
暂时性死区：
	如果区块存在let/const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域，只要在声明之前使用这

些变量，就报错。
var tmp=1;
if(1){
	tmp='12';//ReferenceError
	let tmp;
}

死区
function bar(x=y,y=2){
	return [x,y];
}
bar();//报错
参数x的默认值等于另一个参数y，而此时y没有声明，属于死区。

不允许重复声明
let a=1;let a=2;//报错
function(arg){let arg;}//报错

ES6规定，函数本身的作用域在其所在的块级作用域之内



const
const只声明不赋值会报错
只在声明的块级作用域内有效
变量不提升，存在暂时性死区

对于复合型变量，变量名不指向数据，指向数据所在的地址。const命令只保证变量名指向的地址不变，不保证数据不变。
用Object.freeze保证冻结
const foo=Object.freeze({});
foo.p=1;//不起作用
添加新属性不起作用，如果想对象属性也冻结：
var constantize=(obj)=>{
	Object.freeze(obj);
	Object.keys.forEach((key,value)=>{
		if(typeof obj[key]==='object'){
			constantize(obj[key]);
		}
	});
}

ES5有2中声明变量的方法：var命令和function命令。ES6有let、const、import、class

跨模块常量
//A.js
export const A=1;

//B.js
import * as constants from './A';
console.log(constants.A);//1

//C.js
import {A} from './A';
console.log(A);//1


ES6规定var function声明的全局变量依旧是全局对象的属性，let、const、class声明的全局变量不属于全局对象的属性







第三章
变量的结构赋值

数组结构赋值
var [a,b,c]=[1,2,3];

let [,,third]=['foo','bar','baz']
third // baz

let [head,...tail]=[1,2,3,4];
haed//1
tail//[2,3,4]

解构不成功，变量的值就等于undefined

如果等号右边不是数组（不是可遍历结构）那么会报错
let [foo]=1;let [foo]=null;let [foo]={};//报错

set结构可以使用数组的解构赋值
let [x,y,z]=new Set(["a","b","c"]);x//"a"

只要数据结构具有Iterator接口，都可以采用数组形式的解构赋值
function* fibs(){
	var a=0,b=1;
	while(1){
		yield a;
		[a,b]=[b,a+b];
	}
}
var [first,second,third,fourth,fifth,sixth]=fibs(); sixth//5


解构赋值允许默认值
var [foo=1]=[]; foo//1
ES6内部使用严等===判断一个位置是否有值，如果一个数组成员不严格等于undefined，默认值不生效
var [x=1]=[undefined];x//1
var [x=1]=[null];x//null

如果默认值是一个表达式，那么这个表达式是惰性求值的，只有在用到才会求值。
function f(){console.log(1)}
let [x=f()]=[1]
x能去到值，函数f不会执行，等同：
let x;
if([1][0]===undefined){
	x=f();
}else{
	x=[1][0];
}

默认值可以引用解构赋值的其他变量，该变量必须已经声明。
let [x=1,y=x]=[];//x=1,y=1
let [x=y,y=1]=[];//ReferenceError


对象的解构赋值
var {foo,bar}={foo:'1',bar:'2'};//foo=1,bar=2
数组的元素按次序排列的，变量的取值由它的位置决定；对象的属性没有次序，变量必须与属性同名。
var {baz}={foo:'1',bar:'2'};//baz=undefined
var {foo:baz}={foo:'1',bar:'2'};//baz=1

对象解构赋值实际:
var {foo:foo,bar:bar}={foo:'1',bar:'2'};
对象解构赋值先找到同名属性，然后在赋给对应变量

变量声明和赋值是一体的，对于let、const而言，变量不能重新声明，一旦赋值的变量以前声明过就会报错
let foo;
let {foo}={foo:1};//syntaxError
不用第二个let就不报错
let foo;
({foo}={foo:1});//foo=1

解构可以用于嵌套的对象
var obj={
	p:[1,{y:2}]
};
var {p:[x,{y}]}=obj;
//x=1,y=2 此时p是模式不是变量，因此不会被赋值

对象的解构也可以指定默认值
var {x=3}={};//x=3
默认值生效的条件是对象的属性值严格等于undefined
var {x=3}={x:undefined};x//3

解构失败变量值等于undefined
var {f}={a:1};//f=undefined

解构模式是嵌套的对象，而且子对象所在的父属性不存在那么会报错
var {foo:{bar}}={baz:1};//foo=undefined

var x;
{x}={x:1};
js引擎会将{x}理解成一个代码块，从而发生语法错误，需要加括号。

解构赋值允许左边不放任何变量名
({}='11');	({}=[1,2]);	({}=[]);//可以执行

let {log,sin,cos}=Math;
将Math对象的取对数，正弦，余弦赋值到对应变量上。

字符串的解构赋值
const [a,b,c]='str';//a='s',b='t',c='r

类数组的对象都有length属性，可以对这个属性解构赋值：
let {length:len}='str'; //len=3

数值和布尔值的解构赋值
如果等号右边是数值或者布尔值，会先转为对象:
let {toString:s}=123;
s===Number.prototype.toString //true
let {toString:s}=false;
s===Boolean.prototype.toString //true

由于undefined和null无法转为对象，所以对它们进行解构赋值都会报错
let {prop:x}=undefined;//TypeError
let {prop:y}=null;//TypeError

函数参数的解构赋值
function add([x,y]){return x+y}
add([1,2]) //3

[[1,2],[3,4]].map(([a,b])=>a+b)//[3,7]

函数参数解构赋值使用默认值
function move({x=0,y=0}={}){
	return [x,y]
}
move({x:3,y:8});//[3,8]
move({x:3})//[3,0]
move({});move();//[0,0]

function move({x,y}={x:0,y:0}){
	return [x,y]
}
move({x:3,y:8});//[3,8]
move({x:3})//[3,undefined]
move({});//[undefined,unfined]
move();//[0,0]

[1,undefined,3],map((x='yes')=>x);//[1,'yes',3]

解构赋值不能使用括号的情况(编译器无法一开始就知道一个式子到底是模式还是表达式，必须解析等号才知道。)
1，变量声明语句中，模式不能带有圆括号
var [(a)]=[1];
var {x:(c)}={};
var {o:({p:p})}={o:{p:2}}

2，函数参数中，模式不能带圆括号。函数参数也属于变量声明，因此不能带。
function f([(z)]){return z;}

3，不能将整个模式或嵌套模式中的一层放在圆括号中
({p:a})={p:3};
([a])=[5];
[({p:a}),{x:c}]=[{},{}]

使用圆括号的情况只有一种：赋值语句的非模式部分。
[(b)]=[3]
({p:(d)}={})
[(parseInt.prop)]=[3]
1，都是赋值语句，不是声明语句。2，圆括号都不属于模式的一部分、


变量的解构赋值用途
交换变量的值
[x,y]=[y,x];


从函数返回多个值
function example(){ return [1,2,3]}
var [a,b,c]=example();//a=1,b=2,c=3

function example(){ return {foo:1,bar:2}};}
var {foo,bar}=example();//foo=1,bar=2


函数参数的定义
function f([x,y,z]){}
f([1,2,3]);

function f({x,y,z}){}
f({z:3,y:2,z:1});


提取JSON数据
var jsonData={id:4,status:'a',data:[1,2]};
let {id,status,data:number}=jsonData;
console.log(id,status,number);//4,'a',[1,2]


函数参数的默认值
function f(a=1){}


遍历map结构
任何部署Iterator接口的对象都可以用for..of遍历，map结构原生支持Iterator接口，配合变量的解构赋值获取键名和键值非常

方便
var map=new Map();
map.set('first','hello');
map.set('second','world');
for(let [key,value] of map){
	console.log(key,value);//first hello  second world
}


输入模块的指定方法
const {SourceMapConsumer,SourceNode} = require("source-map");







第四章
字符串扩展
js采取\uxxxx形式表示一个字符，其中xxxx表示字符的码点。这种表示只限于\u0000-\uFFFF之间的字符，超出范围必须用2个双

字节表示(如\uD842\uDFB7)

如果直接在\u后面跟上超过0xFFFF的数值，JS就会理解成\u20BB+7。由于\u20BB是一个不可打印的字符，所以只显示一个空格，

后面跟一个7 （\u20BB7 -- ' 7'）
ES6只要将码点放入大括号就能正确解读字符 （\u{20BB7} -- '𠮷'  \u{41}\u{42}\u{43} -- ABC）
'\u{1F680}'==='\uD83D\uDE80'//true 大括号表示法跟四字节的UTF-16编码是等价的

JS有六种表示一个字符的方法：
'\z'==='z'
'\172'==='z'
'\x7A'==='z'
'\u007A'==='z'
'\u{7A}'==='z'

js内部，字符以UTF-16的格式储存，每个字符固定2字节，对于需要4个字节储存的字符，JS认为是2个字符（'𠮷'.length=2）
ES6的codePointAt能够正确处理4个字节储存的字符，返回一个字符的码点。
var s='𠮷a';
s.codePointAt(0);//134071
s.codePointAt(1);//57271
s.charCodeAt(2);//97
charCodeAt方法会正确返回32位的UTF-16字符的码点

for of 可以识别大于0xFFFF的码点
var s='𠮷a';
for(let i of s){
	console.log(i.codePointAt(0).toString(16));//'20bb7' ''
}

ES5的charAt返回字符串给定位置的字符，但不能识别大于0xFFFF的字符。
ES7提供at()可以识别
'𠮷'.at(0) //𠮷

normalize将字符的不同表示方法统一为同样的形式，称为Unicode正规化
'\u01D1'.normalize()==='\u004F\u030C'.normalize()
normalize方法接收4个参数
1：NFC，默认参数，表示“标准等价（视觉和语义上的等价）合成”，返回多个简单字符的合成字符
2：NFD，表示“标准等价分解”，即在标准等价的前提下返回合成字符分解出的多个简单字符
3：NFKC，表示“兼容等价合成”，返回合成字符，“兼容等价”指的是语义上等价，视觉上不等价
4：NFKD，表示“兼容等价分解”，在兼容等价的前提下，返回合成字符分解出的多个简单字符
normalize不能识别3个或3个以上的字符合成，只能用正则通过unicode编号区间判断


includes:返回布尔值，表示是否找到了参数字符串
startsWith:返回布尔值，表示参数字符串是否在源字符串的头部
endsWith:返回布尔值，表示参数字符串是否在源字符串的尾部
var s='abcde fghi';
s.startsWith('abcd');//true
s.includes('e');//true

第二个参数表示开始搜索的位置
var s='abcde fghi';
s.startsWith(' fghi',5);//true
s.includes('abcde',0);//true


repeat方法返回一个新字符串表示原字符串重复n次
's'.repeat(2);//ss


字符串头部补全padStart
'x'.padStart(5,'ab');//'ababx'

字符串尾部补全padEnd
'x'.padEnd(5,'ab');//'xabab'


模板字符串
var w='world';`hello ${w}`;//"hello world"
${}大括号里面可以进行运算、引用对象属性、调用函数等


?String.raw? 用来充当模板字符串的处理函数，返回一个反斜线都被转义的字符串，对应于替换变量后的模板字符串
String.raw`Hi\n${2+3}`; //"Hi\n5"	
String.raw`Hi\u000A`; //"Hi\u000A"
String.raw`Hi\\n`; //"Hi\\n"
String.raw({raw:'test'},0,1,2);//"t0e1s2t"

?String.raw=function(strings,...values){
	var output="";
	for(var index=0;index<values.length;index++){
		output+=strings.raw[index]+values[index];
	}
	output+=strings.raw[index];
	return output;
}?







第五章
正则的扩展
ES5的RegExp函数只能接受字符串作为参数，var reg=new RegExp("xyz","i");等价于var reg=/xyz/i;
ES6允许RegExp构造函数接受正则表达式作为参数，会返回一个原有正则表达式的拷贝
var reg=new RegExp(/xyz/i); 如果使用RegExp构造函数的第2个参数指定修饰符，则返回的正则表达式会忽略原有的正则表达

式的修饰符，只使用新指定的修饰符。 new RegExp(/abc/ig,'i').flags//"i"

ES6将match,replace,search,split定义在RegExp对象上


u修饰符
用来处理大于\uFFFF的unicode字符
/^\uD83D/u.test('\uD83D\uDC2A') //false

点字符
点（.）字符在正则含义是除换行符之外的任意单个字符。对于码点大于0xFFFF的unicode字符，点字符不能识别，必须加上u修饰符。
var s='𠮷';
/^.$/.test(s)//false
/^.$/u.test(s)//true

unicode字符表示方法
ES6新增使用大括号表示unicode字符的表示方法，在正则中必须加上u修饰符才能识别
/\u{61}/.test('a');//false
/\u{61}/u.test('a');//false

量词
使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的unicode字符
/𠮷{2}/.test('𠮷𠮷');//false
/𠮷{2}/u.test('𠮷𠮷');//true

预定义模式
u修饰符也影响到预定义模式能否正确识别码点大于0xFFFF的unicode字符
/^\S$/.test('𠮷');//false
/^\S$/u.test('𠮷');//true
正确返回字符串长度的函数
function codePointLength(text){
	var result=text.match(/[\s\S]/gu);
	return result?result.length:0;
}

i修饰符
unicode字符的编码不同，但字型接近（\u004B与\u212A都是大写的K）
/[a-z]/i.test('\u212A');//false
/[a-z]/iu.test('\u212A');//false


y修饰符
除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。

y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;
r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]
r1.exec(s) // ["aa"]
r2.exec(s) // null
第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。

const REGEX = /a/g;
REGEX.lastIndex = 2;// 指定从2号位置（y）开始匹配
const match = REGEX.exec('xaya');// 匹配成功
match.index // 3  // 在3号位置匹配成功
REGEX.lastIndex // 4 // 下一次匹配从4号位开始
REGEX.exec('xaxa') // null // 4号位开始匹配失败
lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。

y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。
const REGEX = /a/y;
REGEX.lastIndex = 2;// 指定从2号位置开始匹配
REGEX.exec('xaya') // null// 不是粘连，匹配失败
REGEX.lastIndex = 3;// 指定从3号位置开始匹配
const match = REGEX.exec('xaxa');// 3号位置是粘连，匹配成功
match.index // 3
REGEX.lastIndex // 4

进一步说，y修饰符号隐含了头部匹配的标志^。
/b/y.exec('aba'); // null

在split方法中使用y修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。
没有找到匹配
'x##'.split(/#/y);// [ 'x##' ]

找到两个匹配
'##x'.split(/#/y)// [ '', '', 'x' ]

后续的分隔符只有紧跟前面的分隔符，才会被识别。
'#x#'.split(/#/y)// [ '', 'x#' ]
'##'.split(/#/y)// [ '', '', '' ]

字符串对象的replace方法
const REGEX = /a/gy;
'aaxa'.replace(REGEX, '-') // '--xa'
最后一个a因为不是出现下一次匹配的头部，所以不会被替换。

单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。
'a1a2a3'.match(/a\d/y) // ["a1"]
'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]

y修饰符的一个应用，是从字符串提取token（词元），y修饰符确保了匹配之间不会有漏掉的字符。
const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;
const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;

tokenize(TOKEN_Y, '3 + 4');// [ '3', '+', '4' ]
tokenize(TOKEN_G, '3 + 4');// [ '3', '+', '4' ]

function tokenize(TOKEN_REGEX, str) {
  let result = [];
  let match;
  while (match = TOKEN_REGEX.exec(str)) {
    result.push(match[1]);
  }
  return result;
}
上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。

tokenize(TOKEN_Y, '3x + 4');// [ '3' ]
tokenize(TOKEN_G, '3x + 4');// [ '3', '+', '4' ]
上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。

sticky属性
与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。
var r = /hello\d/y;
r.sticky // true

flags属性
ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。
ES5的source属性,返回正则表达式的正文
/abc/ig.source  // "abc"

ES6的flags属性,返回正则表达式的修饰符
/abc/ig.flags // 'gi'


RegExp.escape()
字符串必须转义，才能作为正则模式。
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
let str = '/path/to/resource.html?search=query';
escapeRegExp(str);// "\/path\/to\/resource\.html\?search=query"
str是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。







第六章
数值的扩展

二进制和八进制表示法
ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。

0b111110111 === 503 // true
0o767 === 503 // true

从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。
非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  'use strict';
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.

如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。
Number('0b111')  // 7
Number('0o10')  // 8


ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。
Number.isFinite()用来检查一个数值是否为有限的（finite）
Number.isNaN()用来检查一个值是否为NaN
与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。

ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。

Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。

ES6在Number对象上面，新增一个极小的常量Number.EPSILON。
Number.EPSILON // 2.220446049250313e-16
Number.EPSILON.toFixed(20) // '0.00000000000000022204'
为浮点数计算，设置一个误差范围，如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果
Number.EPSILON的实质是一个可以接受的误差范围。


安全整数和Number.isSafeInteger()
JavaScript能够准确表示的整数范围在-2^53到2^53之间 （-2^53,2^53）
ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。
Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。


ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。
Math.trunc方法用于去除一个数的小数部分，返回整数部分。
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4


Math.sign方法用来判断一个数到底是正数、负数、还是零。
参数为正数，返回+1；
参数为负数，返回-1；
参数为0，返回0；
参数为-0，返回-0;
其他值，返回NaN
Math.sign(-5) // -1
Math.sign(5) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign(NaN) // NaN


Math.cbrt方法用于计算一个数的立方根
Math.cbrt('8') // 2


Math.clz32() 
JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。
Math.clz32(1000) // 22
Math.clz32(0b01000000000000000000000000000000) // 1

左移运算符（<<）与Math.clz32方法直接相关。
Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 << 1) // 30
Math.clz32(1 << 2) // 29

对于小数，Math.clz32方法只考虑整数部分。


Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。
Math.imul(2, 4)   // 8
Math.imul(-1, 8)  // -8


Math.fround方法返回一个数的单精度浮点数形式。
Math.fround(0)     // 0
Math.fround(1)     // 1
Math.fround(1.337) // 1.3370000123977661
模拟
Math.fround = Math.fround || function(x) {
  return new Float32Array([x])[0];
};


Math.hypot方法返回所有参数的平方和的平方根。
Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755


ES6新增了4个对数相关方法。
（1） Math.expm1()
Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。
Math.expm1(-1) // -0.6321205588285577
Math.expm1(0)  // 0

（2）Math.log1p()
Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。
Math.log1p(1)  // 0.6931471805599453
Math.log1p(0)  // 0

（3）Math.log10()
Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。
Math.log10(2)      // 0.3010299956639812
Math.log10(1)      // 0

（4）Math.log2()
Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。
Math.log2(3)       // 1.584962500721156
Math.log2(2)       // 1


ES6新增了6个三角函数方法。
Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）


ES7 新增了一个指数运算符（**）。
2 ** 2 // 4
2 ** 3 // 8
指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。
let a = 1.5;
a **= 2;
// 等同于 a = a * a;







第七章
数组的扩展
Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。

let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']


// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).forEach(function (p) {
  console.log(p);
});
querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用forEach方法。


只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。
Array.from('hello')// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。

如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。
Array.from([1, 2, 3])// [1, 2, 3]


扩展运算符（...）也可以将某些数据结构转为数组。
function foo() { var args = [...arguments]; }// arguments对象
[...document.querySelectorAll('div')]// NodeList对象

扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。

Array.from({ length: 3 });// [ undefined, undefined, undefined ]

可以用Array.prototype.slice方法替代。
const toArray = (() =>
  Array.from ? Array.from : obj => [].slice.call(obj)
)();

Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。

Array.from(arrayLike, x => x * x);  等同于  Array.from(arrayLike).map(x => x * x);

Array.from([1, 2, 3], (x) => x * x);// [1, 4, 9]

将数组中布尔值为false的成员转为0。
Array.from([1, , 2, , 3], (n) => n || 0);// [1, 0, 2, 0, 3]

返回各种数据的类型。
function typesOf () { return Array.from(arguments, value => typeof value) }
typesOf(null, [], NaN);// ['object', 'object', 'number']

Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。
Array.from({ length: 2 }, () => 'jack');// ['jack', 'jack']

Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。
function countSymbols(string) { return Array.from(string).length; }


Array.of方法用于将一组值，转换为数组。
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。

Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。

Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

Array.of方法可以用下面的代码模拟实现。
function ArrayOf(){
  return [].slice.call(arguments);
}


数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
Array.prototype.copyWithin(target, start = 0, end = this.length);它接受三个参数。
target（必需）：从该位置开始替换数据。
start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。
这三个参数都应该是数值，如果不是，会自动转为数值。

[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。

// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4); // [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1); // [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3); // {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
var i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署TypedArray的copyWithin方法的平台
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5]


数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
[1, 4, -5, 10].find((n) => n < 0);// -5
上面代码找出数组中第一个小于0的成员。

[1, 5, 10, 15].find(function(value, index, arr) { return value > 9; }) // 10
上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。

数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
[1, 5, 10, 15].findIndex(function(value, index, arr) { return value > 9; }) // 2
这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。

另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。
[NaN].indexOf(NaN);// -1
[NaN].findIndex(y => Object.is(NaN, y));// 0
上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。


fill方法使用给定值，填充一个数组。
['a', 'b', 'c'].fill(7);// [7, 7, 7]

new Array(3).fill(7);// [7, 7, 7]
上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。

fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

['a', 'b', 'c'].fill(7, 1, 2); // ['a', 7, 'c']
上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。


ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

for (let index of ['a', 'b'].keys()) { console.log(index); } // 0 1

for (let elem of ['a', 'b'].values()) { console.log(elem); } // 'a' 'b'

for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem); }// 0 "a" 1 "b"
如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。

let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']


Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。

[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。

[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。

if (arr.indexOf(el) !== -1) { // ... }
indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。

[NaN].indexOf(NaN) // -1
includes使用的是不一样的判断算法，就没有这个问题。

[NaN].includes(NaN) // true

下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。
const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(['foo', 'bar'], 'baz'); // => false

Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。
Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。


数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。
Array(3) // [, , ,] Array(3)返回一个具有3个空位的数组。

注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。

ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。
forEach(), filter(), every() 和some()都会跳过空位。
map()会跳过空位，但会保留这个值
join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。

ES6 则是明确将空位转为undefined。

Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。
Array.from(['a',,'b']); // [ "a", undefined, "b" ]

扩展运算符（...）也会将空位转为undefined。
[...['a',,'b']];// [ "a", undefined, "b" ]

copyWithin()会连空位一起拷贝。
[,'a','b',,].copyWithin(2,0) // [,"a",,"a"]

fill()会将空位视为正常的数组位置。
new Array(3).fill('a') // ["a","a","a"]

for...of循环也会遍历空位。
let arr = [, ,];
for (let i of arr) { console.log(1); } // 1 1
上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。

entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。
// entries()
[...[,'a'].entries()] // [[0,undefined], [1,"a"]]

// keys()
[...[,'a'].keys()] // [0,1]

// values()
[...[,'a'].values()] // [undefined,"a"]

// find()
[,'a'].find(x => true) // undefined

// findIndex()
[,'a'].findIndex(x => true) // 0
由于空位的处理规则非常不统一，所以建议避免出现空位。


数组推导提供了简洁的写法，允许直接通过现有数组生成新数组
var a1=[1,2,3];
var a2=[for(i of a1) i*2];  // [2,4,6]
数组a2通过for...of结构直接在a1的基础上生成。
数组推导中，for...of结构总是写在最前面，返回的表达式写在最后面







第8章
函数的扩展
指定函数默认参数，不用||去写，可以
function foo(x, y = 1) { // ... }

如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的
let x = 99;
function foo(p = x + 1) { console.log(p); }
foo() // 100
x = 100;
foo() // 101
上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。

参数默认值可以与解构赋值的默认值，结合起来使用。
function foo({x, y = 5}) { console.log(x, y); }
foo({}) // undefined, 5
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property 'x' of undefined

通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。
function f(x = 1, y) { return [x, y]; }
f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

function f(x, y = 5, z) { return [x, y, z]; }
f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]

指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2

因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入length属性。
(function(...args) {}).length // 0

如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1



如果参数默认值是一个变量，则变量所处的作用域与其他变量的作用域规则是一样的，即先是当前作用域，然后才是全局作用域
var x = 1;
function f(x, y = x) { console.log(y); }
f(2) // 2
上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一

个参数x，而不是全局变量x，所以输出是2。

let x = 1;
function f(y = x) { let x = 2; console.log(y); }
f() // 1
函数调用时y的默认值x未在函数内部生成，所以x指向全局变量，如果不存在全局变量x就会报错

如果函数a的参数默认值是函数b，那么由于函数作用域是其声明时所在所用域，函数b的作用域就不是a，而是全局
let foo='global';

function bar(func=()=>foo){let foo='local';
console.log(func());
}

bar();

利用参数默认值，可以指定某一个参数不得省略
function throwIfMissing(){ throw new Error('missing pparameter'); }
function foo(mustBeProvided = throwIfMissing()){ return mustBeProvided; }
foo();
参数默认值不是在定义时执行，而是运行时执行。如果将参数定为undefined，表明这个参数可以省略



rest参数用于获取函数的多余参数，这样就不需要使用arguments对象
function add(...values){ let sum=0; for(var val of values){ sum+=val; } return sum;}
add(2,5,3);

argument变量的写法
const sortNumbers = () => Array.prototype.slice.call(arguments).sort();

rest参数写法
const sortNumbers = (...numbers) => numbers.sort();

rest参数改写数组push
function push(array,...items){
	items.forEach(function(item){
		array.push(item);
	});
}
var a=[];
push(a,1,2,3);

函数参数的length属性不包括rest参数



扩展运算符 是三个点(...)，将一个数组转为用逗号分隔的参数序列(逗号？)
console.log(...[1,2,3]) //1 2 3
console.log(1,...[2,3,4],5) //1 2 3 4 5

该运算符主要用于函数调用
function push(array,...items){ array.push(...items); }
function add(x,y){ return x+y }
var numbers = [4,38];
add(...numbers);//42

展开数组
//ES5
function f(x,y,z){}
var args = [0,1,2];
f.apply(null,args);

//ES6
function f(x,y,z){}
var args = [0,1,2];
f(...args);

//ES5
Math.max.apply(null,[14,3,4]);

//ES6
Math.max(..[14,3,4]);  ==  Math.max(14,3,4);

//ES5
var arr1=[0,1,2];
var arr2=[3,4,5];
Array.prototype.push.apply(arr1,arr2);

//ES6
var arr1=[0,1,2];
var arr2=[3,4,5];
arr1.push(...arr2);


合并数组
ES5  [1,2].concat(more)
ES6  [1,2,...more]


扩展运算符可以与解构赋值结合起来用于生成数组
//ES5
a=list[0],rest=list.slice(1)

//ES6
[a,...rest]=list


如果扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错
const [...butLast,last]=[1,2,3]//报错
const [first,...butLast,last]=[1,2,3]//报错


将字符串转为真正的数组
[...'ni'] //['n','i']
能够正确识别32位的unicode字符
'x\uD83D\uDE80y'.length//4
[...'x\uD83D\uDE80y'].length//3

正确返回字符串长度的函数 function length(str){ return [...str].length; }


任何类似数组的对象都可以用扩展运算符转为真正的数组
var nodeList = document.querySelectorAll('div');
var array=[...nodeList];

扩展运算符内部调用的是数据结构的iterator接口，因此只要具有iterator接口的对象，都可以使用扩展运算符
map
let map=new Map([
	[1,'one'],
	[2,'two']
]);
let arr=[...map.keys()];//][1,2]

generator函数
var go=function*(){
	yield 1;
	yield 2;
};
[...go()];//[1,2]

如果没有iterator接口的对象使用扩展运算符会报错。


函数的name属性返回该函数的函数名
var func=function(){};
//ES5
func.name //''
//ES6
func.name //'func'

var a=function b(){}
//ES5
a.name //'b'
//ES6
a.name //'b'

Function构造函数返回的函数实例，name属性的值为“anonymous”
(new Function).name //“anonymous”

bind返回的函数，name属性值会加上“bound”前缀
function foo(){}
foo.bind({}).name //"bound foo"
(()=>{}).bind({}).name //"bound "


箭头函数
1，函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象
2，不可以当做构造函数，不能使用new
3，不可以使用arguments对象，该对象在函数体内不存在。可以用rest参数替代
4，不可以使用yield命令，箭头函数不能用作generator函数
箭头函数没有自己的this，内部的this就是外层代码块的this。没有this就不能用作构造函数
不能用call、apply、bind修改this指向，如果箭头函数外层是函数，那可以改变外层函数的this

函数绑定运算符是并排的双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象作为上下文环境绑定到右边的函数上。用来取代call、apply、bind
foo::bar;  ==  bar.bind(foo);
foo::bar(...arguments);  ==  bar.apply(foo,arguments);

如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上
var method=obj::obj.foo;  ==  var method=::obj.foo;
let log=::console.log;  ==  var log=console.log.bind(console);

双冒号运算符返回的是原对象，因此可以采用链式写法


尾调用优化
指某个函数的最后一步是调用另一个函数
function f(x){ return g(x); }

不属于尾调用
// 情况一，调用函数g之后还有赋值操作
function f(x){
  let y = g(x);
  return y;
}

// 情况二，与一类似
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){ g(x); }  等同于   function f(x){ g(x); return undefined; }


尾调用不一定出现在函数尾部，只要是最后一步操作即可
function f(x){
	if(x>0){
		return m(x);
	}
	return n(x);
}
函数m和n都属于尾调用，都是函数f最后一步


尾调用优化
尾调用之所以与其他调用不同，就在于它的特殊的调用位置。

函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。
如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。
如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。
所有的调用帧，就形成一个“调用栈”（call stack）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。

这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}
上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。



尾递归
函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。

如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。

function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。

非尾递归的 Fibonacci 数列实现如下。

function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
尾递归优化过的 Fibonacci 数列实现如下。

function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。

只有开启严格模式尾调用优化才会生效，一旦启用尾调用优化，arguments和caller两个对象包含的信息会被移除，严格模式下直接报错。



递归函数的改写
尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。

这样做的缺点就是不太直观，两个方法可以解决这个问题。

方法一是在尾递归函数之外，再提供一个正常形式的函数。
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}
function factorial(n) {
  return tailFactorial(n, 1);
}
factorial(5) // 120
上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。

函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。
function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}
const factorial = currying(tailFactorial, 1);
factorial(5) // 120
上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。


第二种方法就简单多了，就是采用 ES6 的函数默认值。
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
factorial(5) // 120
上面代码中，参数total有默认值1，所以调用时不用提供这个值。

总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。






尾递归优化的实现
ES3实现尾递归优化
它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。

function sum(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}
sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)
上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归100000次，就会报错，提示超出调用栈的最大次数。

蹦床函数（trampoline）可以将递归执行转为循环执行。
function trampoline(f) {
  while (f && f instanceof Function) {
    f = f();
  }
  return f;
}
上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。

然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。
function sum(x, y) {
  if (y > 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}
上面代码中，sum函数的每次执行，都会返回自身的另一个版本。

现在，使用蹦床函数执行sum，就不会发生调用栈溢出。
trampoline(sum(1, 100000))
// 100001

蹦床函数并不是真正的尾递归优化，下面的实现才是。
function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}
var sum = tco(function(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});
sum(1, 100000)
// 100001

上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。


ES2017 允许函数的最后一个参数有尾逗号
function clownsEverywhere(
  param1,
  param2,
) { /* ... */ }

clownsEverywhere(
  'foo',
  'bar',
);









第9章
对象的扩展

属性的简洁表示法
var birth = '2000/01/01';
var Person = {
  name: '张三',

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log('我的名字是', this.name); }//hello 属性名总是字符串
};


ES6允许字面量定义对象时把表达式放在方括号内。
var lastWord = 'last word';
var a = {
  'first word': 'hello',
  [lastWord]: 'world'
};
a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"


表达式还可以用于定义方法名。
let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};
obj.hello() // hi


注意，属性名表达式与简洁表示法，不能同时使用，会报错。
// 报错
var foo = 'bar';
var bar = 'abc';
var baz = { [foo] };

// 正确
var foo = 'bar';
var baz = { [foo]: 'abc'};

注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]
const keyA = {a: 1};
const keyB = {b: 2};
const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};
myObject // Object {[object Object]: "valueB"}


函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
const person = {
  sayName() {
    console.log('hello!');
  },
};
person.sayName.name   // "sayName"

如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。
const obj = {
  get foo() {},
  set foo(x) {}
};
obj.foo.name// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');
descriptor.get.name // "get foo"
descriptor.set.name // "set foo"

有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。
(new Function()).name // "anonymous"
var doSomething = function() {
  // ...
};
doSomething.bind().name // "bound doSomething"

如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。
const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // "[description]"
obj[key2].name // ""
上面代码中，key1对应的 Symbol 值有描述，key2没有。


