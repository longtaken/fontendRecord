第一章
简介

babel安装
	npm i --global babel-cli
	npm i --save babel-preset-es2015
配置.babelrc
	{"presets":['es2015']}

babel自带一个babel-node命令，提供支持es6的REPL环境，支持nodejs的REPL环境的所有功能，可以直接运行ES6代码。
babel-node 回车后直接编写
babel-node es6.js 直接运行es6脚本
babel es6.js 	  将es6转为es5

-o参数（或--out-file）可以将转换后的代码从标准输出重定向至文件
babel es6.js -o es5.js	babel es6.js --out-file es5.js

-d参数用于转换整个目录
babel -d build-dir source-dir

-s参数生产source map
babel -d build-dir source-dir -s



nodejs环境
npm i -S babel-core babel-preset-2015
创建.babelrc {"presets":["es2015"]}
最后在脚本调用babel-core的transform方法

var es5Code='let x=n=>n+1';
var es6Code=require('babel-core').transform(es5Code,{presets:['es2015']}).code;
transform第一个参数是字符串，表示需要转换的ES5代码，第二个参数是转换的配置对象。

babel加载为require命令的一个钩子：
require("babel-core/register")
后面所有通过require加载的后缀名为.es6、.es、.jsx、.js的脚本都会通过babel转码再加载。

babel默认不会转换Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对

象上的方法（如Object.assign）。如需使用就安装
npm i babel-polyfill -S，然后require('babel-polyfill');













第二章
let const命令

let
let在代码块内有效
不存在变量提升（为声明之前使用typeof也会报错）
暂时性死区：
	如果区块存在let/const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域，只要在声明之前使用这

些变量，就报错。
var tmp=1;
if(1){
	tmp='12';//ReferenceError
	let tmp;
}

死区
function bar(x=y,y=2){
	return [x,y];
}
bar();//报错
参数x的默认值等于另一个参数y，而此时y没有声明，属于死区。

不允许重复声明
let a=1;let a=2;//报错
function(arg){let arg;}//报错

ES6规定，函数本身的作用域在其所在的块级作用域之内




const
const只声明不赋值会报错
只在声明的块级作用域内有效
变量不提升，存在暂时性死区

对于复合型变量，变量名不指向数据，指向数据所在的地址。const命令只保证变量名指向的地址不变，不保证数据不变。
用Object.freeze保证冻结
const foo=Object.freeze({});
foo.p=1;//不起作用
添加新属性不起作用，如果想对象属性也冻结：
var constantize=(obj)=>{
	Object.freeze(obj);
	Object.keys.forEach((key,value)=>{
		if(typeof obj[key]==='object'){
			constantize(obj[key]);
		}
	});
}

ES5有2中声明变量的方法：var命令和function命令。ES6有let、const、import、class

跨模块常量
//A.js
export const A=1;

//B.js
import * as constants from './A';
console.log(constants.A);//1

//C.js
import {A} from './A';
console.log(A);//1


ES6规定var function声明的全局变量依旧是全局对象的属性，let、const、class声明的全局变量不属于全局对象的属性











第三章
变量的结构赋值

数组结构赋值
var [a,b,c]=[1,2,3];

let [,,third]=['foo','bar','baz']
third // baz

let [head,...tail]=[1,2,3,4];
haed//1
tail//[2,3,4]

解构不成功，变量的值就等于undefined

如果等号右边不是数组（不是可遍历结构）那么会报错
let [foo]=1;let [foo]=null;let [foo]={};//报错

set结构可以使用数组的解构赋值
let [x,y,z]=new Set(["a","b","c"]);x//"a"

只要数据结构具有Iterator接口，都可以采用数组形式的解构赋值
function* fibs(){
	var a=0,b=1;
	while(1){
		yield a;
		[a,b]=[b,a+b];
	}
}
var [first,second,third,fourth,fifth,sixth]=fibs(); sixth//5


解构赋值允许默认值
var [foo=1]=[]; foo//1
ES6内部使用严等===判断一个位置是否有值，如果一个数组成员不严格等于undefined，默认值不生效
var [x=1]=[undefined];x//1
var [x=1]=[null];x//null

如果默认值是一个表达式，那么这个表达式是惰性求值的，只有在用到才会求值。
function f(){console.log(1)}
let [x=f()]=[1]
x能去到值，函数f不会执行，等同：
let x;
if([1][0]===undefined){
	x=f();
}else{
	x=[1][0];
}

默认值可以引用解构赋值的其他变量，该变量必须已经声明。
let [x=1,y=x]=[];//x=1,y=1
let [x=y,y=1]=[];//ReferenceError


对象的解构赋值
var {foo,bar}={foo:'1',bar:'2'};//foo=1,bar=2
数组的元素按次序排列的，变量的取值由它的位置决定；对象的属性没有次序，变量必须与属性同名。
var {baz}={foo:'1',bar:'2'};//baz=undefined
var {foo:baz}={foo:'1',bar:'2'};//baz=1

对象解构赋值实际:
var {foo:foo,bar:bar}={foo:'1',bar:'2'};
对象解构赋值先找到同名属性，然后在赋给对应变量

变量声明和赋值是一体的，对于let、const而言，变量不能重新声明，一旦赋值的变量以前声明过就会报错
let foo;
let {foo}={foo:1};//syntaxError
不用第二个let就不报错
let foo;
({foo}={foo:1});//foo=1

解构可以用于嵌套的对象
var obj={
	p:[1,{y:2}]
};
var {p:[x,{y}]}=obj;
//x=1,y=2 此时p是模式不是变量，因此不会被赋值

对象的解构也可以指定默认值
var {x=3}={};//x=3
默认值生效的条件是对象的属性值严格等于undefined
var {x=3}={x:undefined};x//3

解构失败变量值等于undefined
var {f}={a:1};//f=undefined

解构模式是嵌套的对象，而且子对象所在的父属性不存在那么会报错
var {foo:{bar}}={baz:1};//foo=undefined

var x;
{x}={x:1};
js引擎会将{x}理解成一个代码块，从而发生语法错误，需要加括号。

解构赋值允许左边不放任何变量名
({}='11');	({}=[1,2]);	({}=[]);//可以执行

let {log,sin,cos}=Math;
将Math对象的取对数，正弦，余弦赋值到对应变量上。

字符串的解构赋值
const [a,b,c]='str';//a='s',b='t',c='r

类数组的对象都有length属性，可以对这个属性解构赋值：
let {length:len}='str'; //len=3

数值和布尔值的解构赋值
如果等号右边是数值或者布尔值，会先转为对象:
let {toString:s}=123;
s===Number.prototype.toString //true
let {toString:s}=false;
s===Boolean.prototype.toString //true

由于undefined和null无法转为对象，所以对它们进行解构赋值都会报错
let {prop:x}=undefined;//TypeError
let {prop:y}=null;//TypeError

函数参数的解构赋值
function add([x,y]){return x+y}
add([1,2]) //3

[[1,2],[3,4]].map(([a,b])=>a+b)//[3,7]

函数参数解构赋值使用默认值
function move({x=0,y=0}={}){
	return [x,y]
}
move({x:3,y:8});//[3,8]
move({x:3})//[3,0]
move({});move();//[0,0]

function move({x,y}={x:0,y:0}){
	return [x,y]
}
move({x:3,y:8});//[3,8]
move({x:3})//[3,undefined]
move({});//[undefined,unfined]
move();//[0,0]

[1,undefined,3],map((x='yes')=>x);//[1,'yes',3]

解构赋值不能使用括号的情况(编译器无法一开始就知道一个式子到底是模式还是表达式，必须解析等号才知道。)
1，变量声明语句中，模式不能带有圆括号
var [(a)]=[1];
var {x:(c)}={};
var {o:({p:p})}={o:{p:2}}

2，函数参数中，模式不能带圆括号。函数参数也属于变量声明，因此不能带。
function f([(z)]){return z;}

3，不能将整个模式或嵌套模式中的一层放在圆括号中
({p:a})={p:3};
([a])=[5];
[({p:a}),{x:c}]=[{},{}]

使用圆括号的情况只有一种：赋值语句的非模式部分。
[(b)]=[3]
({p:(d)}={})
[(parseInt.prop)]=[3]
1，都是赋值语句，不是声明语句。2，圆括号都不属于模式的一部分、


变量的解构赋值用途
交换变量的值
[x,y]=[y,x];


从函数返回多个值
function example(){ return [1,2,3]}
var [a,b,c]=example();//a=1,b=2,c=3

function example(){ return {foo:1,bar:2}};}
var {foo,bar}=example();//foo=1,bar=2


函数参数的定义
function f([x,y,z]){}
f([1,2,3]);

function f({x,y,z}){}
f({z:3,y:2,z:1});


提取JSON数据
var jsonData={id:4,status:'a',data:[1,2]};
let {id,status,data:number}=jsonData;
console.log(id,status,number);//4,'a',[1,2]


函数参数的默认值
function f(a=1){}


遍历map结构
任何部署Iterator接口的对象都可以用for..of遍历，map结构原生支持Iterator接口，配合变量的解构赋值获取键名和键值非常

方便
var map=new Map();
map.set('first','hello');
map.set('second','world');
for(let [key,value] of map){
	console.log(key,value);//first hello  second world
}


输入模块的指定方法
const {SourceMapConsumer,SourceNode} = require("source-map");











第四章
字符串扩展
js采取\uxxxx形式表示一个字符，其中xxxx表示字符的码点。这种表示只限于\u0000-\uFFFF之间的字符，超出范围必须用2个双

字节表示(如\uD842\uDFB7)

如果直接在\u后面跟上超过0xFFFF的数值，JS就会理解成\u20BB+7。由于\u20BB是一个不可打印的字符，所以只显示一个空格，

后面跟一个7 （\u20BB7 -- ' 7'）
ES6只要将码点放入大括号就能正确解读字符 （\u{20BB7} -- '𠮷'  \u{41}\u{42}\u{43} -- ABC）
'\u{1F680}'==='\uD83D\uDE80'//true 大括号表示法跟四字节的UTF-16编码是等价的

JS有六种表示一个字符的方法：
'\z'==='z'
'\172'==='z'
'\x7A'==='z'
'\u007A'==='z'
'\u{7A}'==='z'

js内部，字符以UTF-16的格式储存，每个字符固定2字节，对于需要4个字节储存的字符，JS认为是2个字符（'𠮷'.length=2）
ES6的codePointAt能够正确处理4个字节储存的字符，返回一个字符的码点。
var s='𠮷a';
s.codePointAt(0);//134071
s.codePointAt(1);//57271
s.charCodeAt(2);//97
charCodeAt方法会正确返回32位的UTF-16字符的码点

for of 可以识别大于0xFFFF的码点
var s='𠮷a';
for(let i of s){
	console.log(i.codePointAt(0).toString(16));//'20bb7' ''
}

ES5的charAt返回字符串给定位置的字符，但不能识别大于0xFFFF的字符。
ES7提供at()可以识别
'𠮷'.at(0) //𠮷

normalize将字符的不同表示方法统一为同样的形式，称为Unicode正规化
'\u01D1'.normalize()==='\u004F\u030C'.normalize()
normalize方法接收4个参数
1：NFC，默认参数，表示“标准等价（视觉和语义上的等价）合成”，返回多个简单字符的合成字符
2：NFD，表示“标准等价分解”，即在标准等价的前提下返回合成字符分解出的多个简单字符
3：NFKC，表示“兼容等价合成”，返回合成字符，“兼容等价”指的是语义上等价，视觉上不等价
4：NFKD，表示“兼容等价分解”，在兼容等价的前提下，返回合成字符分解出的多个简单字符
normalize不能识别3个或3个以上的字符合成，只能用正则通过unicode编号区间判断


includes:返回布尔值，表示是否找到了参数字符串
startsWith:返回布尔值，表示参数字符串是否在源字符串的头部
endsWith:返回布尔值，表示参数字符串是否在源字符串的尾部
var s='abcde fghi';
s.startsWith('abcd');//true
s.includes('e');//true

第二个参数表示开始搜索的位置
var s='abcde fghi';
s.startsWith(' fghi',5);//true
s.includes('abcde',0);//true


repeat方法返回一个新字符串表示原字符串重复n次
's'.repeat(2);//ss


字符串头部补全padStart
'x'.padStart(5,'ab');//'ababx'

字符串尾部补全padEnd
'x'.padEnd(5,'ab');//'xabab'


模板字符串
var w='world';`hello ${w}`;//"hello world"
${}大括号里面可以进行运算、引用对象属性、调用函数等


?String.raw? 用来充当模板字符串的处理函数，返回一个反斜线都被转义的字符串，对应于替换变量后的模板字符串
String.raw`Hi\n${2+3}`; //"Hi\n5"	
String.raw`Hi\u000A`; //"Hi\u000A"
String.raw`Hi\\n`; //"Hi\\n"
String.raw({raw:'test'},0,1,2);//"t0e1s2t"

?String.raw=function(strings,...values){
	var output="";
	for(var index=0;index<values.length;index++){
		output+=strings.raw[index]+values[index];
	}
	output+=strings.raw[index];
	return output;
}?








第五章
正则的扩展
ES5的RegExp函数只能接受字符串作为参数，var reg=new RegExp("xyz","i");等价于var reg=/xyz/i;
ES6允许RegExp构造函数接受正则表达式作为参数，会返回一个原有正则表达式的拷贝
var reg=new RegExp(/xyz/i); 如果使用RegExp构造函数的第2个参数指定修饰符，则返回的正则表达式会忽略原有的正则表达

式的修饰符，只使用新指定的修饰符。 new RegExp(/abc/ig,'i').flags//"i"

ES6将match,replace,search,split定义在RegExp对象上


u修饰符
用来处理大于\uFFFF的unicode字符
/^\uD83D/u.test('\uD83D\uDC2A') //false

点字符
点（.）字符在正则含义是除换行符之外的任意单个字符。对于码点大于0xFFFF的unicode字符，点字符不能识别，必须加上u修饰符。
var s='𠮷';
/^.$/.test(s)//false
/^.$/u.test(s)//true

unicode字符表示方法
ES6新增使用大括号表示unicode字符的表示方法，在正则中必须加上u修饰符才能识别
/\u{61}/.test('a');//false
/\u{61}/u.test('a');//false

量词
使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的unicode字符
/𠮷{2}/.test('𠮷𠮷');//false
/𠮷{2}/u.test('𠮷𠮷');//true

预定义模式
u修饰符也影响到预定义模式能否正确识别码点大于0xFFFF的unicode字符
/^\S$/.test('𠮷');//false
/^\S$/u.test('𠮷');//true
正确返回字符串长度的函数
function codePointLength(text){
	var result=text.match(/[\s\S]/gu);
	return result?result.length:0;
}

i修饰符
unicode字符的编码不同，但字型接近（\u004B与\u212A都是大写的K）
/[a-z]/i.test('\u212A');//false
/[a-z]/iu.test('\u212A');//false


y修饰符
除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。

y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;
r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]
r1.exec(s) // ["aa"]
r2.exec(s) // null
第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。

const REGEX = /a/g;
REGEX.lastIndex = 2;// 指定从2号位置（y）开始匹配
const match = REGEX.exec('xaya');// 匹配成功
match.index // 3  // 在3号位置匹配成功
REGEX.lastIndex // 4 // 下一次匹配从4号位开始
REGEX.exec('xaxa') // null // 4号位开始匹配失败
lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。

y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。
const REGEX = /a/y;
REGEX.lastIndex = 2;// 指定从2号位置开始匹配
REGEX.exec('xaya') // null// 不是粘连，匹配失败
REGEX.lastIndex = 3;// 指定从3号位置开始匹配
const match = REGEX.exec('xaxa');// 3号位置是粘连，匹配成功
match.index // 3
REGEX.lastIndex // 4

进一步说，y修饰符号隐含了头部匹配的标志^。
/b/y.exec('aba'); // null

在split方法中使用y修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。
没有找到匹配
'x##'.split(/#/y);// [ 'x##' ]

找到两个匹配
'##x'.split(/#/y)// [ '', '', 'x' ]

后续的分隔符只有紧跟前面的分隔符，才会被识别。
'#x#'.split(/#/y)// [ '', 'x#' ]
'##'.split(/#/y)// [ '', '', '' ]

字符串对象的replace方法
const REGEX = /a/gy;
'aaxa'.replace(REGEX, '-') // '--xa'
最后一个a因为不是出现下一次匹配的头部，所以不会被替换。

单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。
'a1a2a3'.match(/a\d/y) // ["a1"]
'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]

y修饰符的一个应用，是从字符串提取token（词元），y修饰符确保了匹配之间不会有漏掉的字符。
const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;
const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;

tokenize(TOKEN_Y, '3 + 4');// [ '3', '+', '4' ]
tokenize(TOKEN_G, '3 + 4');// [ '3', '+', '4' ]

function tokenize(TOKEN_REGEX, str) {
  let result = [];
  let match;
  while (match = TOKEN_REGEX.exec(str)) {
    result.push(match[1]);
  }
  return result;
}
上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。

tokenize(TOKEN_Y, '3x + 4');// [ '3' ]
tokenize(TOKEN_G, '3x + 4');// [ '3', '+', '4' ]
上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。

sticky属性
与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。
var r = /hello\d/y;
r.sticky // true

flags属性
ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。
ES5的source属性,返回正则表达式的正文
/abc/ig.source  // "abc"

ES6的flags属性,返回正则表达式的修饰符
/abc/ig.flags // 'gi'


RegExp.escape()
字符串必须转义，才能作为正则模式。
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
let str = '/path/to/resource.html?search=query';
escapeRegExp(str);// "\/path\/to\/resource\.html\?search=query"
str是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。











第六章
数值的扩展

二进制和八进制表示法
ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。

0b111110111 === 503 // true
0o767 === 503 // true

从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。
非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  'use strict';
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.

如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。
Number('0b111')  // 7
Number('0o10')  // 8


ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。
Number.isFinite()用来检查一个数值是否为有限的（finite）
Number.isNaN()用来检查一个值是否为NaN
与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。

ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。

Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。

ES6在Number对象上面，新增一个极小的常量Number.EPSILON。
Number.EPSILON // 2.220446049250313e-16
Number.EPSILON.toFixed(20) // '0.00000000000000022204'
为浮点数计算，设置一个误差范围，如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果
Number.EPSILON的实质是一个可以接受的误差范围。


安全整数和Number.isSafeInteger()
JavaScript能够准确表示的整数范围在-2^53到2^53之间 （-2^53,2^53）
ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。
Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。


ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。
Math.trunc方法用于去除一个数的小数部分，返回整数部分。
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4


Math.sign方法用来判断一个数到底是正数、负数、还是零。
参数为正数，返回+1；
参数为负数，返回-1；
参数为0，返回0；
参数为-0，返回-0;
其他值，返回NaN
Math.sign(-5) // -1
Math.sign(5) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign(NaN) // NaN


Math.cbrt方法用于计算一个数的立方根
Math.cbrt('8') // 2


Math.clz32() 
JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。
Math.clz32(1000) // 22
Math.clz32(0b01000000000000000000000000000000) // 1

左移运算符（<<）与Math.clz32方法直接相关。
Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 << 1) // 30
Math.clz32(1 << 2) // 29

对于小数，Math.clz32方法只考虑整数部分。


Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。
Math.imul(2, 4)   // 8
Math.imul(-1, 8)  // -8


Math.fround方法返回一个数的单精度浮点数形式。
Math.fround(0)     // 0
Math.fround(1)     // 1
Math.fround(1.337) // 1.3370000123977661
模拟
Math.fround = Math.fround || function(x) {
  return new Float32Array([x])[0];
};


Math.hypot方法返回所有参数的平方和的平方根。
Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755


ES6新增了4个对数相关方法。
（1） Math.expm1()
Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。
Math.expm1(-1) // -0.6321205588285577
Math.expm1(0)  // 0

（2）Math.log1p()
Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。
Math.log1p(1)  // 0.6931471805599453
Math.log1p(0)  // 0

（3）Math.log10()
Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。
Math.log10(2)      // 0.3010299956639812
Math.log10(1)      // 0

（4）Math.log2()
Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。
Math.log2(3)       // 1.584962500721156
Math.log2(2)       // 1


ES6新增了6个三角函数方法。
Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）


ES7 新增了一个指数运算符（**）。
2 ** 2 // 4
2 ** 3 // 8
指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。
let a = 1.5;
a **= 2;
// 等同于 a = a * a;









第七章
数组的扩展
Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。

let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']


// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).forEach(function (p) {
  console.log(p);
});
querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用forEach方法。


只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。
Array.from('hello')// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。

如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。
Array.from([1, 2, 3])// [1, 2, 3]


