第一章
简介

babel安装
	npm i --global babel-cli
	npm i --save babel-preset-es2015
配置.babelrc
	{"presets":['es2015']}

babel自带一个babel-node命令，提供支持es6的REPL环境，支持nodejs的REPL环境的所有功能，可以直接运行ES6代码。
babel-node 回车后直接编写
babel-node es6.js 直接运行es6脚本
babel es6.js 	  将es6转为es5

-o参数（或--out-file）可以将转换后的代码从标准输出重定向至文件
babel es6.js -o es5.js	babel es6.js --out-file es5.js

-d参数用于转换整个目录
babel -d build-dir source-dir

-s参数生产source map
babel -d build-dir source-dir -s


nodejs环境
npm i -S babel-core babel-preset-2015
创建.babelrc {"presets":["es2015"]}
最后在脚本调用babel-core的transform方法

var es5Code='let x=n=>n+1';
var es6Code=require('babel-core').transform(es5Code,{presets:['es2015']}).code;
transform第一个参数是字符串，表示需要转换的ES5代码，第二个参数是转换的配置对象。

babel加载为require命令的一个钩子：
require("babel-core/register")
后面所有通过require加载的后缀名为.es6、.es、.jsx、.js的脚本都会通过babel转码再加载。

babel默认不会转换Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对

象上的方法（如Object.assign）。如需使用就安装
npm i babel-polyfill -S，然后require('babel-polyfill');






第二章
let const命令

let
let在代码块内有效
不存在变量提升（为声明之前使用typeof也会报错）
暂时性死区：
	如果区块存在let/const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域，只要在声明之前使用这

些变量，就报错。
var tmp=1;
if(1){
	tmp='12';//ReferenceError
	let tmp;
}

死区
function bar(x=y,y=2){
	return [x,y];
}
bar();//报错
参数x的默认值等于另一个参数y，而此时y没有声明，属于死区。

不允许重复声明
let a=1;let a=2;//报错
function(arg){let arg;}//报错

ES6规定，函数本身的作用域在其所在的块级作用域之内



const
const只声明不赋值会报错
只在声明的块级作用域内有效
变量不提升，存在暂时性死区

对于复合型变量，变量名不指向数据，指向数据所在的地址。const命令只保证变量名指向的地址不变，不保证数据不变。
用Object.freeze保证冻结
const foo=Object.freeze({});
foo.p=1;//不起作用
添加新属性不起作用，如果想对象属性也冻结：
var constantize=(obj)=>{
	Object.freeze(obj);
	Object.keys.forEach((key,value)=>{
		if(typeof obj[key]==='object'){
			constantize(obj[key]);
		}
	});
}

ES5有2中声明变量的方法：var命令和function命令。ES6有let、const、import、class

跨模块常量
//A.js
export const A=1;

//B.js
import * as constants from './A';
console.log(constants.A);//1

//C.js
import {A} from './A';
console.log(A);//1


ES6规定var function声明的全局变量依旧是全局对象的属性，let、const、class声明的全局变量不属于全局对象的属性







第三章
变量的结构赋值

数组结构赋值
var [a,b,c]=[1,2,3];

let [,,third]=['foo','bar','baz']
third // baz

let [head,...tail]=[1,2,3,4];
haed//1
tail//[2,3,4]

解构不成功，变量的值就等于undefined

如果等号右边不是数组（不是可遍历结构）那么会报错
let [foo]=1;let [foo]=null;let [foo]={};//报错

set结构可以使用数组的解构赋值
let [x,y,z]=new Set(["a","b","c"]);x//"a"

只要数据结构具有Iterator接口，都可以采用数组形式的解构赋值
function* fibs(){
	var a=0,b=1;
	while(1){
		yield a;
		[a,b]=[b,a+b];
	}
}
var [first,second,third,fourth,fifth,sixth]=fibs(); sixth//5


解构赋值允许默认值
var [foo=1]=[]; foo//1
ES6内部使用严等===判断一个位置是否有值，如果一个数组成员不严格等于undefined，默认值不生效
var [x=1]=[undefined];x//1
var [x=1]=[null];x//null

如果默认值是一个表达式，那么这个表达式是惰性求值的，只有在用到才会求值。
function f(){console.log(1)}
let [x=f()]=[1]
x能去到值，函数f不会执行，等同：
let x;
if([1][0]===undefined){
	x=f();
}else{
	x=[1][0];
}

默认值可以引用解构赋值的其他变量，该变量必须已经声明。
let [x=1,y=x]=[];//x=1,y=1
let [x=y,y=1]=[];//ReferenceError


对象的解构赋值
var {foo,bar}={foo:'1',bar:'2'};//foo=1,bar=2
数组的元素按次序排列的，变量的取值由它的位置决定；对象的属性没有次序，变量必须与属性同名。
var {baz}={foo:'1',bar:'2'};//baz=undefined
var {foo:baz}={foo:'1',bar:'2'};//baz=1

对象解构赋值实际:
var {foo:foo,bar:bar}={foo:'1',bar:'2'};
对象解构赋值先找到同名属性，然后在赋给对应变量

变量声明和赋值是一体的，对于let、const而言，变量不能重新声明，一旦赋值的变量以前声明过就会报错
let foo;
let {foo}={foo:1};//syntaxError
不用第二个let就不报错
let foo;
({foo}={foo:1});//foo=1

解构可以用于嵌套的对象
var obj={
	p:[1,{y:2}]
};
var {p:[x,{y}]}=obj;
//x=1,y=2 此时p是模式不是变量，因此不会被赋值

对象的解构也可以指定默认值
var {x=3}={};//x=3
默认值生效的条件是对象的属性值严格等于undefined
var {x=3}={x:undefined};x//3

解构失败变量值等于undefined
var {f}={a:1};//f=undefined

解构模式是嵌套的对象，而且子对象所在的父属性不存在那么会报错
var {foo:{bar}}={baz:1};//foo=undefined

var x;
{x}={x:1};
js引擎会将{x}理解成一个代码块，从而发生语法错误，需要加括号。

解构赋值允许左边不放任何变量名
({}='11');	({}=[1,2]);	({}=[]);//可以执行

let {log,sin,cos}=Math;
将Math对象的取对数，正弦，余弦赋值到对应变量上。

字符串的解构赋值
const [a,b,c]='str';//a='s',b='t',c='r

类数组的对象都有length属性，可以对这个属性解构赋值：
let {length:len}='str'; //len=3

数值和布尔值的解构赋值
如果等号右边是数值或者布尔值，会先转为对象:
let {toString:s}=123;
s===Number.prototype.toString //true
let {toString:s}=false;
s===Boolean.prototype.toString //true

由于undefined和null无法转为对象，所以对它们进行解构赋值都会报错
let {prop:x}=undefined;//TypeError
let {prop:y}=null;//TypeError

函数参数的解构赋值
function add([x,y]){return x+y}
add([1,2]) //3

[[1,2],[3,4]].map(([a,b])=>a+b)//[3,7]

函数参数解构赋值使用默认值
function move({x=0,y=0}={}){
	return [x,y]
}
move({x:3,y:8});//[3,8]
move({x:3})//[3,0]
move({});move();//[0,0]

function move({x,y}={x:0,y:0}){
	return [x,y]
}
move({x:3,y:8});//[3,8]
move({x:3})//[3,undefined]
move({});//[undefined,unfined]
move();//[0,0]

[1,undefined,3],map((x='yes')=>x);//[1,'yes',3]

解构赋值不能使用括号的情况(编译器无法一开始就知道一个式子到底是模式还是表达式，必须解析等号才知道。)
1，变量声明语句中，模式不能带有圆括号
var [(a)]=[1];
var {x:(c)}={};
var {o:({p:p})}={o:{p:2}}

2，函数参数中，模式不能带圆括号。函数参数也属于变量声明，因此不能带。
function f([(z)]){return z;}

3，不能将整个模式或嵌套模式中的一层放在圆括号中
({p:a})={p:3};
([a])=[5];
[({p:a}),{x:c}]=[{},{}]

使用圆括号的情况只有一种：赋值语句的非模式部分。
[(b)]=[3]
({p:(d)}={})
[(parseInt.prop)]=[3]
1，都是赋值语句，不是声明语句。2，圆括号都不属于模式的一部分、


变量的解构赋值用途
交换变量的值
[x,y]=[y,x];


从函数返回多个值
function example(){ return [1,2,3]}
var [a,b,c]=example();//a=1,b=2,c=3

function example(){ return {foo:1,bar:2}};}
var {foo,bar}=example();//foo=1,bar=2


函数参数的定义
function f([x,y,z]){}
f([1,2,3]);

function f({x,y,z}){}
f({z:3,y:2,z:1});


提取JSON数据
var jsonData={id:4,status:'a',data:[1,2]};
let {id,status,data:number}=jsonData;
console.log(id,status,number);//4,'a',[1,2]


函数参数的默认值
function f(a=1){}


遍历map结构
任何部署Iterator接口的对象都可以用for..of遍历，map结构原生支持Iterator接口，配合变量的解构赋值获取键名和键值非常

方便
var map=new Map();
map.set('first','hello');
map.set('second','world');
for(let [key,value] of map){
	console.log(key,value);//first hello  second world
}


输入模块的指定方法
const {SourceMapConsumer,SourceNode} = require("source-map");







第四章
字符串扩展
js采取\uxxxx形式表示一个字符，其中xxxx表示字符的码点。这种表示只限于\u0000-\uFFFF之间的字符，超出范围必须用2个双

字节表示(如\uD842\uDFB7)

如果直接在\u后面跟上超过0xFFFF的数值，JS就会理解成\u20BB+7。由于\u20BB是一个不可打印的字符，所以只显示一个空格，

后面跟一个7 （\u20BB7 -- ' 7'）
ES6只要将码点放入大括号就能正确解读字符 （\u{20BB7} -- '𠮷'  \u{41}\u{42}\u{43} -- ABC）
'\u{1F680}'==='\uD83D\uDE80'//true 大括号表示法跟四字节的UTF-16编码是等价的

JS有六种表示一个字符的方法：
'\z'==='z'
'\172'==='z'
'\x7A'==='z'
'\u007A'==='z'
'\u{7A}'==='z'

js内部，字符以UTF-16的格式储存，每个字符固定2字节，对于需要4个字节储存的字符，JS认为是2个字符（'𠮷'.length=2）
ES6的codePointAt能够正确处理4个字节储存的字符，返回一个字符的码点。
var s='𠮷a';
s.codePointAt(0);//134071
s.codePointAt(1);//57271
s.charCodeAt(2);//97
charCodeAt方法会正确返回32位的UTF-16字符的码点

for of 可以识别大于0xFFFF的码点
var s='𠮷a';
for(let i of s){
	console.log(i.codePointAt(0).toString(16));//'20bb7' ''
}

ES5的charAt返回字符串给定位置的字符，但不能识别大于0xFFFF的字符。
ES7提供at()可以识别
'𠮷'.at(0) //𠮷

normalize将字符的不同表示方法统一为同样的形式，称为Unicode正规化
'\u01D1'.normalize()==='\u004F\u030C'.normalize()
normalize方法接收4个参数
1：NFC，默认参数，表示“标准等价（视觉和语义上的等价）合成”，返回多个简单字符的合成字符
2：NFD，表示“标准等价分解”，即在标准等价的前提下返回合成字符分解出的多个简单字符
3：NFKC，表示“兼容等价合成”，返回合成字符，“兼容等价”指的是语义上等价，视觉上不等价
4：NFKD，表示“兼容等价分解”，在兼容等价的前提下，返回合成字符分解出的多个简单字符
normalize不能识别3个或3个以上的字符合成，只能用正则通过unicode编号区间判断


includes:返回布尔值，表示是否找到了参数字符串
startsWith:返回布尔值，表示参数字符串是否在源字符串的头部
endsWith:返回布尔值，表示参数字符串是否在源字符串的尾部
var s='abcde fghi';
s.startsWith('abcd');//true
s.includes('e');//true

第二个参数表示开始搜索的位置
var s='abcde fghi';
s.startsWith(' fghi',5);//true
s.includes('abcde',0);//true


repeat方法返回一个新字符串表示原字符串重复n次
's'.repeat(2);//ss


字符串头部补全padStart
'x'.padStart(5,'ab');//'ababx'

字符串尾部补全padEnd
'x'.padEnd(5,'ab');//'xabab'


模板字符串
var w='world';`hello ${w}`;//"hello world"
${}大括号里面可以进行运算、引用对象属性、调用函数等


?String.raw? 用来充当模板字符串的处理函数，返回一个反斜线都被转义的字符串，对应于替换变量后的模板字符串
String.raw`Hi\n${2+3}`; //"Hi\n5"	
String.raw`Hi\u000A`; //"Hi\u000A"
String.raw`Hi\\n`; //"Hi\\n"
String.raw({raw:'test'},0,1,2);//"t0e1s2t"

?String.raw=function(strings,...values){
	var output="";
	for(var index=0;index<values.length;index++){
		output+=strings.raw[index]+values[index];
	}
	output+=strings.raw[index];
	return output;
}?







第五章
正则的扩展
ES5的RegExp函数只能接受字符串作为参数，var reg=new RegExp("xyz","i");等价于var reg=/xyz/i;
ES6允许RegExp构造函数接受正则表达式作为参数，会返回一个原有正则表达式的拷贝
var reg=new RegExp(/xyz/i); 如果使用RegExp构造函数的第2个参数指定修饰符，则返回的正则表达式会忽略原有的正则表达

式的修饰符，只使用新指定的修饰符。 new RegExp(/abc/ig,'i').flags//"i"

ES6将match,replace,search,split定义在RegExp对象上


u修饰符
用来处理大于\uFFFF的unicode字符
/^\uD83D/u.test('\uD83D\uDC2A') //false

点字符
点（.）字符在正则含义是除换行符之外的任意单个字符。对于码点大于0xFFFF的unicode字符，点字符不能识别，必须加上u修饰符。
var s='𠮷';
/^.$/.test(s)//false
/^.$/u.test(s)//true

unicode字符表示方法
ES6新增使用大括号表示unicode字符的表示方法，在正则中必须加上u修饰符才能识别
/\u{61}/.test('a');//false
/\u{61}/u.test('a');//false

量词
使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的unicode字符
/𠮷{2}/.test('𠮷𠮷');//false
/𠮷{2}/u.test('𠮷𠮷');//true

预定义模式
u修饰符也影响到预定义模式能否正确识别码点大于0xFFFF的unicode字符
/^\S$/.test('𠮷');//false
/^\S$/u.test('𠮷');//true
正确返回字符串长度的函数
function codePointLength(text){
	var result=text.match(/[\s\S]/gu);
	return result?result.length:0;
}

i修饰符
unicode字符的编码不同，但字型接近（\u004B与\u212A都是大写的K）
/[a-z]/i.test('\u212A');//false
/[a-z]/iu.test('\u212A');//false


y修饰符
除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。

y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;
r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]
r1.exec(s) // ["aa"]
r2.exec(s) // null
第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。

const REGEX = /a/g;
REGEX.lastIndex = 2;// 指定从2号位置（y）开始匹配
const match = REGEX.exec('xaya');// 匹配成功
match.index // 3  // 在3号位置匹配成功
REGEX.lastIndex // 4 // 下一次匹配从4号位开始
REGEX.exec('xaxa') // null // 4号位开始匹配失败
lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。

y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。
const REGEX = /a/y;
REGEX.lastIndex = 2;// 指定从2号位置开始匹配
REGEX.exec('xaya') // null// 不是粘连，匹配失败
REGEX.lastIndex = 3;// 指定从3号位置开始匹配
const match = REGEX.exec('xaxa');// 3号位置是粘连，匹配成功
match.index // 3
REGEX.lastIndex // 4

进一步说，y修饰符号隐含了头部匹配的标志^。
/b/y.exec('aba'); // null

在split方法中使用y修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。
没有找到匹配
'x##'.split(/#/y);// [ 'x##' ]

找到两个匹配
'##x'.split(/#/y)// [ '', '', 'x' ]

后续的分隔符只有紧跟前面的分隔符，才会被识别。
'#x#'.split(/#/y)// [ '', 'x#' ]
'##'.split(/#/y)// [ '', '', '' ]

字符串对象的replace方法
const REGEX = /a/gy;
'aaxa'.replace(REGEX, '-') // '--xa'
最后一个a因为不是出现下一次匹配的头部，所以不会被替换。

单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。
'a1a2a3'.match(/a\d/y) // ["a1"]
'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]

y修饰符的一个应用，是从字符串提取token（词元），y修饰符确保了匹配之间不会有漏掉的字符。
const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;
const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;

tokenize(TOKEN_Y, '3 + 4');// [ '3', '+', '4' ]
tokenize(TOKEN_G, '3 + 4');// [ '3', '+', '4' ]

function tokenize(TOKEN_REGEX, str) {
  let result = [];
  let match;
  while (match = TOKEN_REGEX.exec(str)) {
    result.push(match[1]);
  }
  return result;
}
上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。

tokenize(TOKEN_Y, '3x + 4');// [ '3' ]
tokenize(TOKEN_G, '3x + 4');// [ '3', '+', '4' ]
上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。

sticky属性
与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。
var r = /hello\d/y;
r.sticky // true

flags属性
ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。
ES5的source属性,返回正则表达式的正文
/abc/ig.source  // "abc"

ES6的flags属性,返回正则表达式的修饰符
/abc/ig.flags // 'gi'


RegExp.escape()
字符串必须转义，才能作为正则模式。
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
let str = '/path/to/resource.html?search=query';
escapeRegExp(str);// "\/path\/to\/resource\.html\?search=query"
str是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。







第六章
数值的扩展

二进制和八进制表示法
ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。

0b111110111 === 503 // true
0o767 === 503 // true

从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。
非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  'use strict';
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.

如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。
Number('0b111')  // 7
Number('0o10')  // 8


ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。
Number.isFinite()用来检查一个数值是否为有限的（finite）
Number.isNaN()用来检查一个值是否为NaN
与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。

ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。

Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。

ES6在Number对象上面，新增一个极小的常量Number.EPSILON。
Number.EPSILON // 2.220446049250313e-16
Number.EPSILON.toFixed(20) // '0.00000000000000022204'
为浮点数计算，设置一个误差范围，如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果
Number.EPSILON的实质是一个可以接受的误差范围。


安全整数和Number.isSafeInteger()
JavaScript能够准确表示的整数范围在-2^53到2^53之间 （-2^53,2^53）
ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。
Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。


ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。
Math.trunc方法用于去除一个数的小数部分，返回整数部分。
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4


Math.sign方法用来判断一个数到底是正数、负数、还是零。
参数为正数，返回+1；
参数为负数，返回-1；
参数为0，返回0；
参数为-0，返回-0;
其他值，返回NaN
Math.sign(-5) // -1
Math.sign(5) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign(NaN) // NaN


Math.cbrt方法用于计算一个数的立方根
Math.cbrt('8') // 2


Math.clz32() 
JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。
Math.clz32(1000) // 22
Math.clz32(0b01000000000000000000000000000000) // 1

左移运算符（<<）与Math.clz32方法直接相关。
Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 << 1) // 30
Math.clz32(1 << 2) // 29

对于小数，Math.clz32方法只考虑整数部分。


Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。
Math.imul(2, 4)   // 8
Math.imul(-1, 8)  // -8


Math.fround方法返回一个数的单精度浮点数形式。
Math.fround(0)     // 0
Math.fround(1)     // 1
Math.fround(1.337) // 1.3370000123977661
模拟
Math.fround = Math.fround || function(x) {
  return new Float32Array([x])[0];
};


Math.hypot方法返回所有参数的平方和的平方根。
Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755


ES6新增了4个对数相关方法。
（1） Math.expm1()
Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。
Math.expm1(-1) // -0.6321205588285577
Math.expm1(0)  // 0

（2）Math.log1p()
Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。
Math.log1p(1)  // 0.6931471805599453
Math.log1p(0)  // 0

（3）Math.log10()
Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。
Math.log10(2)      // 0.3010299956639812
Math.log10(1)      // 0

（4）Math.log2()
Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。
Math.log2(3)       // 1.584962500721156
Math.log2(2)       // 1


ES6新增了6个三角函数方法。
Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）


ES7 新增了一个指数运算符（**）。
2 ** 2 // 4
2 ** 3 // 8
指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。
let a = 1.5;
a **= 2;
// 等同于 a = a * a;







第七章
数组的扩展
Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。

let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']


// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).forEach(function (p) {
  console.log(p);
});
querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用forEach方法。


只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。
Array.from('hello')// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。

如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。
Array.from([1, 2, 3])// [1, 2, 3]


扩展运算符（...）也可以将某些数据结构转为数组。
function foo() { var args = [...arguments]; }// arguments对象
[...document.querySelectorAll('div')]// NodeList对象

扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。

Array.from({ length: 3 });// [ undefined, undefined, undefined ]

可以用Array.prototype.slice方法替代。
const toArray = (() =>
  Array.from ? Array.from : obj => [].slice.call(obj)
)();

Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。

Array.from(arrayLike, x => x * x);  等同于  Array.from(arrayLike).map(x => x * x);

Array.from([1, 2, 3], (x) => x * x);// [1, 4, 9]

将数组中布尔值为false的成员转为0。
Array.from([1, , 2, , 3], (n) => n || 0);// [1, 0, 2, 0, 3]

返回各种数据的类型。
function typesOf () { return Array.from(arguments, value => typeof value) }
typesOf(null, [], NaN);// ['object', 'object', 'number']

Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。
Array.from({ length: 2 }, () => 'jack');// ['jack', 'jack']

Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。
function countSymbols(string) { return Array.from(string).length; }


Array.of方法用于将一组值，转换为数组。
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。

Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。

Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

Array.of方法可以用下面的代码模拟实现。
function ArrayOf(){
  return [].slice.call(arguments);
}


数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
Array.prototype.copyWithin(target, start = 0, end = this.length);它接受三个参数。
target（必需）：从该位置开始替换数据。
start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。
这三个参数都应该是数值，如果不是，会自动转为数值。

[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。

// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4); // [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1); // [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3); // {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
var i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署TypedArray的copyWithin方法的平台
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5]


数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。
[1, 4, -5, 10].find((n) => n < 0);// -5
上面代码找出数组中第一个小于0的成员。

[1, 5, 10, 15].find(function(value, index, arr) { return value > 9; }) // 10
上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。

数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
[1, 5, 10, 15].findIndex(function(value, index, arr) { return value > 9; }) // 2
这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。

另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。
[NaN].indexOf(NaN);// -1
[NaN].findIndex(y => Object.is(NaN, y));// 0
上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。


fill方法使用给定值，填充一个数组。
['a', 'b', 'c'].fill(7);// [7, 7, 7]

new Array(3).fill(7);// [7, 7, 7]
上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。

fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。

['a', 'b', 'c'].fill(7, 1, 2); // ['a', 7, 'c']
上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。


ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。

for (let index of ['a', 'b'].keys()) { console.log(index); } // 0 1

for (let elem of ['a', 'b'].values()) { console.log(elem); } // 'a' 'b'

for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem); }// 0 "a" 1 "b"
如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。

let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']


Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。

[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。

[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。

if (arr.indexOf(el) !== -1) { // ... }
indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。

[NaN].indexOf(NaN) // -1
includes使用的是不一样的判断算法，就没有这个问题。

[NaN].includes(NaN) // true

下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。
const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(['foo', 'bar'], 'baz'); // => false

Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。
Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。


数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。
Array(3) // [, , ,] Array(3)返回一个具有3个空位的数组。

注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。

ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。
forEach(), filter(), every() 和some()都会跳过空位。
map()会跳过空位，但会保留这个值
join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。

ES6 则是明确将空位转为undefined。

Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。
Array.from(['a',,'b']); // [ "a", undefined, "b" ]

扩展运算符（...）也会将空位转为undefined。
[...['a',,'b']];// [ "a", undefined, "b" ]

copyWithin()会连空位一起拷贝。
[,'a','b',,].copyWithin(2,0) // [,"a",,"a"]

fill()会将空位视为正常的数组位置。
new Array(3).fill('a') // ["a","a","a"]

for...of循环也会遍历空位。
let arr = [, ,];
for (let i of arr) { console.log(1); } // 1 1
上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。

entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。
// entries()
[...[,'a'].entries()] // [[0,undefined], [1,"a"]]

// keys()
[...[,'a'].keys()] // [0,1]

// values()
[...[,'a'].values()] // [undefined,"a"]

// find()
[,'a'].find(x => true) // undefined

// findIndex()
[,'a'].findIndex(x => true) // 0
由于空位的处理规则非常不统一，所以建议避免出现空位。


数组推导提供了简洁的写法，允许直接通过现有数组生成新数组
var a1=[1,2,3];
var a2=[for(i of a1) i*2];  // [2,4,6]
数组a2通过for...of结构直接在a1的基础上生成。
数组推导中，for...of结构总是写在最前面，返回的表达式写在最后面







第8章
函数的扩展
指定函数默认参数，不用||去写，可以
function foo(x, y = 1) { // ... }

如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的
let x = 99;
function foo(p = x + 1) { console.log(p); }
foo() // 100
x = 100;
foo() // 101
上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。

参数默认值可以与解构赋值的默认值，结合起来使用。
function foo({x, y = 5}) { console.log(x, y); }
foo({}) // undefined, 5
foo({x: 1}) // 1, 5
foo({x: 1, y: 2}) // 1, 2
foo() // TypeError: Cannot read property 'x' of undefined

通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。
function f(x = 1, y) { return [x, y]; }
f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

function f(x, y = 5, z) { return [x, y, z]; }
f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]

指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2

因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest 参数也不会计入length属性。
(function(...args) {}).length // 0

如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1

一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。
var x = 1;
function f(x, y = x) { console.log(y); }
f(2) // 2
上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。

let x = 1;
function f(y = x) { let x = 2; console.log(y); }
f() // 1
函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。
